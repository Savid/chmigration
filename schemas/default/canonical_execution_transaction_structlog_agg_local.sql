CREATE TABLE default.canonical_execution_transaction_structlog_agg_local\n(\n    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),\n    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),\n    `transaction_hash` FixedString(66) COMMENT \'The transaction hash\' CODEC(ZSTD(1)),\n    `transaction_index` UInt32 COMMENT \'The transaction position in the block\' CODEC(DoubleDelta, ZSTD(1)),\n    `call_frame_id` UInt32 COMMENT \'Sequential frame ID within the transaction (0=root)\' CODEC(DoubleDelta, ZSTD(1)),\n    `parent_call_frame_id` Nullable(UInt32) COMMENT \'Parent frame ID (NULL for root frame)\' CODEC(ZSTD(1)),\n    `call_frame_path` Array(UInt32) COMMENT \'Path of frame IDs from root to current frame\' CODEC(ZSTD(1)),\n    `depth` UInt32 COMMENT \'Call nesting depth (0=root)\' CODEC(DoubleDelta, ZSTD(1)),\n    `target_address` Nullable(String) COMMENT \'Contract address being called\' CODEC(ZSTD(1)),\n    `call_type` LowCardinality(String) COMMENT \'Call type: CALL/DELEGATECALL/STATICCALL/CALLCODE/CREATE/CREATE2 (empty for root)\',\n    `operation` LowCardinality(String) COMMENT \'Opcode name for per-opcode rows, empty string for frame summary rows\',\n    `opcode_count` UInt64 COMMENT \'Number of opcodes (total for summary row, count for per-opcode row)\' CODEC(ZSTD(1)),\n    `error_count` UInt64 COMMENT \'Number of errors\' CODEC(ZSTD(1)),\n    `gas` UInt64 COMMENT \'Gas consumed: SUM(gas_self) for per-opcode, frame self gas for summary\' CODEC(ZSTD(1)),\n    `gas_cumulative` UInt64 COMMENT \'Cumulative gas: SUM(gas_used) for per-opcode, frame total for summary\' CODEC(ZSTD(1)),\n    `min_depth` UInt32 COMMENT \'Minimum depth where opcode appeared (per-opcode rows)\' CODEC(DoubleDelta, ZSTD(1)),\n    `max_depth` UInt32 COMMENT \'Maximum depth where opcode appeared (per-opcode rows)\' CODEC(DoubleDelta, ZSTD(1)),\n    `memory_words_sum_before` UInt64 DEFAULT 0 COMMENT \'SUM(ceil(memory_bytes/32)) before each opcode executes. Used with sq_sum to compute memory expansion gas.\' CODEC(ZSTD(1)),\n    `memory_words_sum_after` UInt64 DEFAULT 0 COMMENT \'SUM(ceil(memory_bytes/32)) after each opcode executes.\' CODEC(ZSTD(1)),\n    `memory_words_sq_sum_before` UInt64 DEFAULT 0 COMMENT \'SUM(words_before²). With sum_before, enables exact memory gas via E[cost(after)] - E[cost(before)].\' CODEC(ZSTD(1)),\n    `memory_words_sq_sum_after` UInt64 DEFAULT 0 COMMENT \'SUM(words_after²). With sum_after, enables exact memory gas via E[cost(after)] - E[cost(before)].\' CODEC(ZSTD(1)),\n    `memory_expansion_gas` UInt64 DEFAULT 0 COMMENT \'SUM(memory_expansion_gas). Exact per-opcode memory expansion cost, pre-computed to avoid intDiv rounding in SQL reconstruction.\' CODEC(ZSTD(1)),\n    `cold_access_count` UInt64 DEFAULT 0 COMMENT \'Number of cold storage/account accesses (EIP-2929). cold_gas = cold_count * (cold_cost - warm_cost).\' CODEC(ZSTD(1)),\n    `gas_refund` Nullable(UInt64) COMMENT \'Gas refund (root summary row only)\' CODEC(ZSTD(1)),\n    `intrinsic_gas` Nullable(UInt64) COMMENT \'Intrinsic gas (root summary row only, computed)\' CODEC(ZSTD(1)),\n    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'\n)\nENGINE = ReplicatedReplacingMergeTree(\'/clickhouse/{installation}/{cluster}/default/tables/canonical_execution_transaction_structlog_agg_local/{shard}\', \'{replica}\', updated_date_time)\nPARTITION BY intDiv(block_number, 201600)\nORDER BY (block_number, meta_network_name, transaction_hash, call_frame_id, operation)\nSETTINGS index_granularity = 8192\nCOMMENT 'Aggregated EVM execution data. Summary rows (operation="") contain frame metadata. Per-opcode rows contain aggregated gas/count per (frame, opcode).'\n

-- Migration 102: Schema V2 (GENERATED)
--
-- Source: schemas + spec.yaml
-- This file is generated by generate_migration.py.

CREATE DATABASE IF NOT EXISTS observoor ON CLUSTER '{cluster}';

CREATE DATABASE IF NOT EXISTS admin ON CLUSTER '{cluster}';

-- LOCAL TABLES
-- default database

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_beacon_blob_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT 'When this row was last updated' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) CODEC(ZSTD(1)),
    `block_parent_root` FixedString(66) CODEC(ZSTD(1)),
    `proposer_index` UInt32 CODEC(ZSTD(1)),
    `blob_index` UInt64 CODEC(ZSTD(1)),
    `kzg_commitment` FixedString(98) CODEC(ZSTD(1)),
    `versioned_hash` FixedString(66) CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String),
    `meta_consensus_version` LowCardinality(String),
    `meta_consensus_version_major` LowCardinality(String),
    `meta_consensus_version_minor` LowCardinality(String),
    `meta_consensus_version_patch` LowCardinality(String),
    `meta_consensus_implementation` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, block_root, blob_index)
COMMENT 'Contains beacon API blob metadata derived from block blob_kzg_commitments from each sentry client attached to a beacon node';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_beacon_committee_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon API committee payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `committee_index` LowCardinality(String) COMMENT \'The committee index in the beacon API committee payload\',
    `validators` Array(UInt32) COMMENT \'The validator indices in the beacon API committee payload\' CODEC(ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API committee payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, committee_index)
COMMENT 'Contains beacon API /eth/v1/beacon/states/{state_id}/committees data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_attestation_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT 'When this row was last updated' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'The difference between the event_date_time and the slot_start_date_time\' CODEC(ZSTD(1)),
    `committee_index` LowCardinality(String) COMMENT \'The committee index in the beacon API event stream payload\',
    `attesting_validator_index` Nullable(UInt32) COMMENT \'The index of the validator attesting to the event\' CODEC(ZSTD(1)),
    `attesting_validator_committee_index` LowCardinality(String) COMMENT \'The committee index of the attesting validator\',
    `aggregation_bits` String COMMENT \'The aggregation bits of the event in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `beacon_block_root` FixedString(66) COMMENT \'The beacon block root hash in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `source_epoch` UInt32 COMMENT \'The source epoch number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `source_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the source epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `source_root` FixedString(66) COMMENT \'The source beacon block root hash in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `target_epoch` UInt32 COMMENT \'The target epoch number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `target_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the target epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `target_root` FixedString(66) COMMENT \'The target beacon block root hash in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name)
COMMENT 'Contains beacon API attestation events from each sentry client attached to a beacon node';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_blob_sidecar_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'The difference between the event_date_time and the slot_start_date_time\' CODEC(ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The beacon block root hash in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `blob_index` UInt64 COMMENT \'The index of blob sidecar in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `kzg_commitment` FixedString(98) COMMENT \'The KZG commitment in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `versioned_hash` FixedString(66) COMMENT \'The versioned hash in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, block_root, blob_index)
COMMENT 'Contains beacon API eventstream "blob_sidecar" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_block_gossip_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'The difference between the event_date_time and the slot_start_date_time\' CODEC(ZSTD(1)),
    `block` FixedString(66) COMMENT \'The beacon block root hash in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, block)
COMMENT 'Contains beacon API eventstream "block_gossip" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_block_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'The difference between the event_date_time and the slot_start_date_time\' CODEC(ZSTD(1)),
    `block` FixedString(66) COMMENT \'The beacon block root hash in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `execution_optimistic` Bool COMMENT \'If the attached beacon node is running in execution optimistic mode\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, block)
COMMENT 'Contains beacon API eventstream "block" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_chain_reorg_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number of the chain reorg event in the beacon API event stream payload\',
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the reorg slot started\',
    `propagation_slot_start_diff` UInt32 COMMENT \'Difference in slots between when the reorg occurred and when the sentry received the event\',
    `depth` UInt16 COMMENT \'The depth of the chain reorg in the beacon API event stream payload\',
    `old_head_block` FixedString(66) COMMENT \'The old head block root hash in the beacon API event stream payload\',
    `new_head_block` FixedString(66) COMMENT \'The new head block root hash in the beacon API event stream payload\',
    `old_head_state` FixedString(66) COMMENT \'The old head state root hash in the beacon API event stream payload\',
    `new_head_state` FixedString(66) COMMENT \'The new head state root hash in the beacon API event stream payload\',
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\',
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\',
    `execution_optimistic` Bool COMMENT \'Whether the execution of the epoch was optimistic\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\',
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\',
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\',
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\',
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\',
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\',
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\',
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\',
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\',
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, old_head_block, new_head_block)
COMMENT 'Contains beacon API eventstream "chain reorg" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_contribution_and_proof_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `aggregator_index` UInt32 COMMENT \'The validator index of the aggregator in the beacon API event stream payload\',
    `contribution_slot` UInt32 COMMENT \'The slot number of the contribution in the beacon API event stream payload\',
    `contribution_slot_start_date_time` DateTime COMMENT \'The wall clock time when the contribution slot started\',
    `contribution_propagation_slot_start_diff` UInt32 COMMENT \'Difference in slots between when the contribution occurred and when the sentry received the event\',
    `contribution_beacon_block_root` FixedString(66) COMMENT \'The beacon block root hash in the beacon API event stream payload\',
    `contribution_subcommittee_index` LowCardinality(String) COMMENT \'The subcommittee index of the contribution in the beacon API event stream payload\',
    `contribution_aggregation_bits` String COMMENT \'The aggregation bits of the contribution in the beacon API event stream payload\',
    `contribution_signature` String COMMENT \'The signature of the contribution in the beacon API event stream payload\',
    `contribution_epoch` UInt32 COMMENT \'The epoch number of the contribution in the beacon API event stream payload\',
    `contribution_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the contribution epoch started\',
    `selection_proof` String COMMENT \'The selection proof in the beacon API event stream payload\',
    `signature` String COMMENT \'The signature in the beacon API event stream payload\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\',
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\',
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\',
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\',
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\',
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\',
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\',
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\',
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\',
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(contribution_slot_start_date_time))
ORDER BY (meta_network_name, contribution_slot_start_date_time, meta_client_name, contribution_beacon_block_root, contribution_subcommittee_index, signature)
COMMENT 'Contains beacon API eventstream "contribution and proof" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_data_column_sidecar_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'The difference between the event_date_time and the slot_start_date_time\' CODEC(ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The beacon block root hash in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `column_index` UInt64 COMMENT \'The index of column in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `kzg_commitments_count` UInt32 COMMENT \'Number of KZG commitments associated with the record\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, block_root, column_index)
COMMENT 'Contains beacon API eventstream "data_column_sidecar" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_finalized_checkpoint_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\',
    `block` FixedString(66) COMMENT \'The finalized block root hash in the beacon API event stream payload\',
    `state` FixedString(66) COMMENT \'The finalized state root hash in the beacon API event stream payload\',
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `execution_optimistic` Bool COMMENT \'Whether the execution of the epoch was optimistic\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(epoch_start_date_time))
ORDER BY (meta_network_name, epoch_start_date_time, meta_client_name, block, state)
COMMENT 'Contains beacon API eventstream "finalized checkpoint" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_head_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon API event stream payload\',
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\',
    `propagation_slot_start_diff` UInt32 COMMENT \'The difference between the event_date_time and the slot_start_date_time\',
    `block` FixedString(66) COMMENT \'The beacon block root hash in the beacon API event stream payload\',
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\',
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\',
    `epoch_transition` Bool COMMENT \'If the event is an epoch transition\',
    `execution_optimistic` Bool COMMENT \'If the attached beacon node is running in execution optimistic mode\',
    `previous_duty_dependent_root` FixedString(66) COMMENT \'The previous duty dependent root in the beacon API event stream payload\',
    `current_duty_dependent_root` FixedString(66) COMMENT \'The current duty dependent root in the beacon API event stream payload\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\',
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\',
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\',
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\',
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\',
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\',
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\',
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\',
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\',
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, block, previous_duty_dependent_root, current_duty_dependent_root)
COMMENT 'Contains beacon API eventstream "head" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_voluntary_exit_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\',
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\',
    `wallclock_slot` UInt32 COMMENT \'Slot number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime COMMENT \'Start date and time of the wall clock slot when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch` UInt32 COMMENT \'Epoch number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch_start_date_time` DateTime COMMENT \'Start date and time of the wall clock epoch when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `validator_index` UInt32 COMMENT \'The index of the validator making the voluntary exit\',
    `signature` String COMMENT \'The signature of the voluntary exit in the beacon API event stream payload\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\',
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\',
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\',
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\',
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\',
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\',
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\',
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\',
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\',
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(wallclock_epoch_start_date_time))
ORDER BY (meta_network_name, wallclock_epoch_start_date_time, meta_client_name, validator_index)
COMMENT 'Contains beacon API eventstream "voluntary exit" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_proposer_duty_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the client fetched the beacon block from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `proposer_validator_index` UInt32 COMMENT \'The validator index from the proposer duty payload\' CODEC(ZSTD(1)),
    `proposer_pubkey` String COMMENT \'The BLS public key of the validator from the proposer duty payload\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, proposer_validator_index)
COMMENT 'Contains a proposer duty from a beacon block.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_validator_attestation_data_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon API validator attestation data payload\',
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\',
    `committee_index` LowCardinality(String) COMMENT \'The committee index in the beacon API validator attestation data payload\',
    `beacon_block_root` FixedString(66) COMMENT \'The beacon block root hash in the beacon API validator attestation data payload\',
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API validator attestation data payload\',
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\',
    `source_epoch` UInt32 COMMENT \'The source epoch number in the beacon API validator attestation data payload\',
    `source_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the source epoch started\',
    `source_root` FixedString(66) COMMENT \'The source beacon block root hash in the beacon API validator attestation data payload\',
    `target_epoch` UInt32 COMMENT \'The target epoch number in the beacon API validator attestation data payload\',
    `target_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the target epoch started\',
    `target_root` FixedString(66) COMMENT \'The target beacon block root hash in the beacon API validator attestation data payload\',
    `request_date_time` DateTime COMMENT \'When the request was sent to the beacon node\',
    `request_duration` UInt32 COMMENT \'The request duration in milliseconds\',
    `request_slot_start_diff` UInt32 COMMENT \'The difference between the request_date_time and the slot_start_date_time\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\',
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\',
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\',
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\',
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\',
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\',
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\',
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\',
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\',
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, committee_index, beacon_block_root, source_root, target_root)
COMMENT 'Contains beacon API validator attestation data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v2_beacon_block_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\',
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the reorg slot started\',
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\',
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\',
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\',
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `block_total_bytes` Nullable(UInt32) COMMENT \'The total bytes of the beacon block payload\',
    `block_total_bytes_compressed` Nullable(UInt32) COMMENT \'The total bytes of the beacon block payload when compressed using snappy\',
    `parent_root` FixedString(66) COMMENT \'The root hash of the parent beacon block\',
    `state_root` FixedString(66) COMMENT \'The root hash of the beacon state at this block\',
    `proposer_index` UInt32 COMMENT \'The index of the validator that proposed the beacon block\',
    `eth1_data_block_hash` FixedString(66) COMMENT \'The block hash of the associated execution block\',
    `eth1_data_deposit_root` FixedString(66) COMMENT \'The root of the deposit tree in the associated execution block\',
    `execution_payload_block_hash` Nullable(FixedString(66)) COMMENT \'The block hash of the execution payload\',
    `execution_payload_block_number` Nullable(UInt32) COMMENT \'The block number of the execution payload\',
    `execution_payload_fee_recipient` Nullable(String) COMMENT \'The recipient of the fee for this execution payload\',
    `execution_payload_base_fee_per_gas` Nullable(UInt128) COMMENT \'Base fee per gas for execution payload\' CODEC(ZSTD(1)),
    `execution_payload_blob_gas_used` Nullable(UInt64) COMMENT \'Gas used for blobs in execution payload\' CODEC(ZSTD(1)),
    `execution_payload_excess_blob_gas` Nullable(UInt64) COMMENT \'Excess gas used for blobs in execution payload\' CODEC(ZSTD(1)),
    `execution_payload_gas_limit` Nullable(UInt64) COMMENT \'Gas limit for execution payload\' CODEC(DoubleDelta, ZSTD(1)),
    `execution_payload_gas_used` Nullable(UInt64) COMMENT \'Gas used for execution payload\' CODEC(ZSTD(1)),
    `execution_payload_state_root` FixedString(66) COMMENT \'The state root of the execution payload\',
    `execution_payload_parent_hash` FixedString(66) COMMENT \'The parent hash of the execution payload\',
    `execution_payload_transactions_count` Nullable(UInt32) COMMENT \'The transaction count of the execution payload\',
    `execution_payload_transactions_total_bytes` Nullable(UInt32) COMMENT \'The transaction total bytes of the execution payload\',
    `execution_payload_transactions_total_bytes_compressed` Nullable(UInt32) COMMENT \'The transaction total bytes of the execution payload when compressed using snappy\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\',
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\',
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\',
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\',
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\',
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\',
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\',
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\',
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\',
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, block_root, parent_root, state_root)
COMMENT 'Contains beacon API /eth/v2/beacon/blocks/{block_id} data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v3_validator_block_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number within the payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API event stream payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `block_total_bytes` Nullable(UInt32) COMMENT \'The total bytes of the beacon block payload\' CODEC(ZSTD(1)),
    `block_total_bytes_compressed` Nullable(UInt32) COMMENT \'The total bytes of the beacon block payload when compressed using snappy\' CODEC(ZSTD(1)),
    `consensus_payload_value` Nullable(UInt64) COMMENT \'Consensus rewards paid to the proposer for this block, in Wei. Use to determine relative value of consensus blocks.\' CODEC(ZSTD(1)),
    `execution_payload_value` Nullable(UInt64) COMMENT \'Execution payload value in Wei. Use to determine relative value of execution payload.\' CODEC(ZSTD(1)),
    `execution_payload_block_number` UInt32 COMMENT \'The block number of the execution payload\',
    `execution_payload_base_fee_per_gas` Nullable(UInt128) COMMENT \'Base fee per gas for execution payload\' CODEC(ZSTD(1)),
    `execution_payload_blob_gas_used` Nullable(UInt64) COMMENT \'Gas used for blobs in execution payload\' CODEC(ZSTD(1)),
    `execution_payload_excess_blob_gas` Nullable(UInt64) COMMENT \'Excess gas used for blobs in execution payload\' CODEC(ZSTD(1)),
    `execution_payload_gas_limit` Nullable(UInt64) COMMENT \'Gas limit for execution payload\' CODEC(DoubleDelta, ZSTD(1)),
    `execution_payload_gas_used` Nullable(UInt64) COMMENT \'Gas used for execution payload\' CODEC(ZSTD(1)),
    `execution_payload_transactions_count` Nullable(UInt32) COMMENT \'The transaction count of the execution payload\' CODEC(ZSTD(1)),
    `execution_payload_transactions_total_bytes` Nullable(UInt32) COMMENT \'The transaction total bytes of the execution payload\' CODEC(ZSTD(1)),
    `execution_payload_transactions_total_bytes_compressed` Nullable(UInt32) COMMENT \'The transaction total bytes of the execution payload when compressed using snappy\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\',
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\',
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\',
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\',
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\',
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, event_date_time)
COMMENT 'Contains beacon API /eth/v3/validator/blocks/{slot} data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_slot_local ON CLUSTER '{cluster}'
(
    `slot` UInt32 COMMENT \'Slot number\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `blocks` AggregateFunction(sum, UInt16) COMMENT \'The number of beacon blocks seen in the slot\' CODEC(ZSTD(1)),
    `attestations` AggregateFunction(sum, UInt32) COMMENT \'The number of attestations seen in the slot\' CODEC(ZSTD(1))
)
ENGINE = ReplicatedMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}')
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, slot)
COMMENT 'Contains beacon API slot data from each sentry client attached to a beacon node';

CREATE TABLE IF NOT EXISTS default.beacon_block_classification_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the client fetched the beacon block classification\',
    `slot` UInt32 COMMENT \'The slot number from beacon block classification\',
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block classification\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `best_guess_single` LowCardinality(String) COMMENT \'The best guess of the client that generated the beacon block\',
    `best_guess_multi` LowCardinality(String) COMMENT \'The best guess of the clients that generated the beacon block. This value will typically equal the best_guess_single value, but when multiple clients have high probabilities, this value will have multiple eg. "prysm or lighthouse"\',
    `client_probability_uncertain` Float32 COMMENT \'The probability that the client that generated the beacon block is uncertain\' CODEC(ZSTD(1)),
    `client_probability_prysm` Float32 COMMENT \'The probability that the client that generated the beacon block is Prysm\' CODEC(ZSTD(1)),
    `client_probability_teku` Float32 COMMENT \'The probability that the client that generated the beacon block is Teku\' CODEC(ZSTD(1)),
    `client_probability_nimbus` Float32 COMMENT \'The probability that the client that generated the beacon block is Nimbus\' CODEC(ZSTD(1)),
    `client_probability_lodestar` Float32 COMMENT \'The probability that the client that generated the beacon block is Lodestar\' CODEC(ZSTD(1)),
    `client_probability_grandine` Float32 COMMENT \'The probability that the client that generated the beacon block is Grandine\' CODEC(ZSTD(1)),
    `client_probability_lighthouse` Float32 COMMENT \'The probability that the client that generated the beacon block is Lighthouse\' CODEC(ZSTD(1)),
    `proposer_index` UInt32 COMMENT \'The index of the validator that proposed the beacon block\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, proposer_index)
COMMENT 'Contains beacon block classification for a given slot. This is a best guess based on the client probabilities of the proposer. This is not guaranteed to be correct.';

CREATE TABLE IF NOT EXISTS default.blob_submitter_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `address` FixedString(66) COMMENT \'Ethereum address of the blob submitter\' CODEC(ZSTD(1)),
    `name` String COMMENT \'Name of the blob submitter\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY meta_network_name
ORDER BY (meta_network_name, address)
COMMENT 'Contains blob submitter address to name mappings.';

CREATE TABLE IF NOT EXISTS default.block_native_mempool_transaction_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `detecttime` DateTime64(3) COMMENT \'Timestamp that the transaction was detected in mempool\' CODEC(DoubleDelta, ZSTD(1)),
    `hash` FixedString(66) COMMENT \'Unique identifier hash for a given transaction\' CODEC(ZSTD(1)),
    `status` LowCardinality(String) COMMENT \'Status of the transaction\',
    `region` LowCardinality(String) COMMENT \'The geographic region for the node that detected the transaction\',
    `reorg` Nullable(FixedString(66)) COMMENT \'If there was a reorg, refers to the blockhash of the reorg\' CODEC(ZSTD(1)),
    `replace` Nullable(FixedString(66)) COMMENT \'If the transaction was replaced (speedup/cancel), the transaction hash of the replacement\' CODEC(ZSTD(1)),
    `curblocknumber` Nullable(UInt64) COMMENT \'The block number the event was detected in\' CODEC(ZSTD(1)),
    `failurereason` Nullable(String) COMMENT \'If a transaction failed, this field provides contextual information\' CODEC(ZSTD(1)),
    `blockspending` Nullable(UInt64) COMMENT \'If a transaction was finalized (confirmed, failed), this refers to the number of blocks that the transaction was waiting to get on-chain\' CODEC(ZSTD(1)),
    `timepending` Nullable(UInt64) COMMENT \'If a transaction was finalized (confirmed, failed), this refers to the time in milliseconds that the transaction was waiting to get on-chain\' CODEC(ZSTD(1)),
    `nonce` UInt64 COMMENT \'A unique number which counts the number of transactions sent from a given address\' CODEC(ZSTD(1)),
    `gas` UInt64 COMMENT \'The maximum number of gas units allowed for the transaction\' CODEC(ZSTD(1)),
    `gasprice` UInt128 COMMENT \'The price offered to the miner/validator per unit of gas. Denominated in wei\' CODEC(ZSTD(1)),
    `value` UInt128 COMMENT \'The amount of ETH transferred or sent to contract. Denominated in wei\' CODEC(ZSTD(1)),
    `toaddress` Nullable(FixedString(42)) COMMENT \'The destination of a given transaction\' CODEC(ZSTD(1)),
    `fromaddress` FixedString(42) COMMENT \'The source/initiator of a given transaction\' CODEC(ZSTD(1)),
    `datasize` UInt32 COMMENT \'The size of the call data of the transaction in bytes\' CODEC(ZSTD(1)),
    `data4bytes` Nullable(FixedString(10)) COMMENT \'The first 4 bytes of the call data of the transaction\' CODEC(ZSTD(1)),
    `network` LowCardinality(String) COMMENT \'The specific Ethereum network used\',
    `type` UInt8 COMMENT \'"Post EIP-1559, this indicates how the gas parameters are submitted to the network: - type 0 - legacy - type 1 - usage of access lists according to EIP-2930 - type 2 - using maxpriorityfeepergas and maxfeepergas"\' CODEC(ZSTD(1)),
    `maxpriorityfeepergas` Nullable(UInt128) COMMENT \'The maximum value for a tip offered to the miner/validator per unit of gas. The actual tip paid can be lower if (maxfee - basefee) < maxpriorityfee. Denominated in wei\' CODEC(ZSTD(1)),
    `maxfeepergas` Nullable(UInt128) COMMENT \'The maximum value for the transaction fee (including basefee and tip) offered to the miner/validator per unit of gas. Denominated in wei\' CODEC(ZSTD(1)),
    `basefeepergas` Nullable(UInt128) COMMENT \'The fee per unit of gas paid and burned for the curblocknumber. This fee is algorithmically determined. Denominated in wei\' CODEC(ZSTD(1)),
    `dropreason` Nullable(String) COMMENT \'If the transaction was dropped from the mempool, this describes the contextual reason for the drop\' CODEC(ZSTD(1)),
    `rejectionreason` Nullable(String) COMMENT \'If the transaction was rejected from the mempool, this describes the contextual reason for the rejection\' CODEC(ZSTD(1)),
    `stuck` Bool COMMENT \'A transaction was detected in the queued area of the mempool and is not eligible for inclusion in a block\' CODEC(ZSTD(1)),
    `gasused` Nullable(UInt64) COMMENT \'If the transaction was published on-chain, this value indicates the amount of gas that was actually consumed. Denominated in wei\' CODEC(ZSTD(1))
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (network, toYYYYMM(detecttime))
ORDER BY (network, detecttime, hash, fromaddress, nonce, gas)
COMMENT 'Contains transactions from block native mempool dataset';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_blob_sidecar_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_parent_root` FixedString(66) COMMENT \'The root hash of the parent beacon block\' CODEC(ZSTD(1)),
    `versioned_hash` FixedString(66) COMMENT \'The versioned hash in the beacon API event stream payload\' CODEC(ZSTD(1)),
    `kzg_commitment` FixedString(98) COMMENT \'The KZG commitment in the blob sidecar payload\' CODEC(ZSTD(1)),
    `kzg_proof` FixedString(98) COMMENT \'The KZG proof in the blob sidecar payload\' CODEC(ZSTD(1)),
    `proposer_index` UInt32 COMMENT \'The index of the validator that proposed the beacon block\' CODEC(ZSTD(1)),
    `blob_index` UInt64 COMMENT \'The index of blob sidecar in the blob sidecar payload\' CODEC(ZSTD(1)),
    `blob_size` UInt32 COMMENT \'The total bytes of the blob\' CODEC(ZSTD(1)),
    `blob_empty_size` Nullable(UInt32) COMMENT \'The total empty size of the blob in bytes\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, block_root, blob_index)
COMMENT 'Contains a blob sidecar from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_attester_slashing_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `attestation_1_attesting_indices` Array(UInt32) COMMENT \'The attesting indices from the first attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_1_signature` String COMMENT \'The signature from the first attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_1_data_beacon_block_root` FixedString(66) COMMENT \'The beacon block root from the first attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_1_data_slot` UInt32 COMMENT \'The slot number from the first attestation in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `attestation_1_data_index` UInt32 COMMENT \'The attestor index from the first attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_1_data_source_epoch` UInt32 COMMENT \'The source epoch number from the first attestation in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `attestation_1_data_source_root` FixedString(66) COMMENT \'The source root from the first attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_1_data_target_epoch` UInt32 COMMENT \'The target epoch number from the first attestation in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `attestation_1_data_target_root` FixedString(66) COMMENT \'The target root from the first attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_2_attesting_indices` Array(UInt32) COMMENT \'The attesting indices from the second attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_2_signature` String COMMENT \'The signature from the second attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_2_data_beacon_block_root` FixedString(66) COMMENT \'The beacon block root from the second attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_2_data_slot` UInt32 COMMENT \'The slot number from the second attestation in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `attestation_2_data_index` UInt32 COMMENT \'The attestor index from the second attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_2_data_source_epoch` UInt32 COMMENT \'The source epoch number from the second attestation in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `attestation_2_data_source_root` FixedString(66) COMMENT \'The source root from the second attestation in the slashing payload\' CODEC(ZSTD(1)),
    `attestation_2_data_target_epoch` UInt32 COMMENT \'The target epoch number from the second attestation in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `attestation_2_data_target_root` FixedString(66) COMMENT \'The target root from the second attestation in the slashing payload\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, block_root, attestation_1_attesting_indices, attestation_2_attesting_indices, attestation_1_data_slot, attestation_2_data_slot, attestation_1_data_beacon_block_root, attestation_2_data_beacon_block_root)
COMMENT 'Contains attester slashing from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_bls_to_execution_change_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `exchanging_message_validator_index` UInt32 COMMENT \'The validator index from the exchanging message\' CODEC(ZSTD(1)),
    `exchanging_message_from_bls_pubkey` String COMMENT \'The BLS public key from the exchanging message\' CODEC(ZSTD(1)),
    `exchanging_message_to_execution_address` FixedString(42) COMMENT \'The execution address from the exchanging message\' CODEC(ZSTD(1)),
    `exchanging_signature` String COMMENT \'The signature for the exchanging message\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, block_root, exchanging_message_validator_index, exchanging_message_from_bls_pubkey, exchanging_message_to_execution_address)
COMMENT 'Contains bls to execution change from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_deposit_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `deposit_proof` Array(String) COMMENT \'The proof of the deposit data\' CODEC(ZSTD(1)),
    `deposit_data_pubkey` String COMMENT \'The BLS public key of the validator from the deposit data\' CODEC(ZSTD(1)),
    `deposit_data_withdrawal_credentials` FixedString(66) COMMENT \'The withdrawal credentials of the validator from the deposit data\' CODEC(ZSTD(1)),
    `deposit_data_amount` UInt128 COMMENT \'The amount of the deposit from the deposit data\' CODEC(ZSTD(1)),
    `deposit_data_signature` String COMMENT \'The signature of the deposit data\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, block_root, deposit_data_pubkey, deposit_proof)
COMMENT 'Contains a deposit from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_execution_transaction_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `position` UInt32 COMMENT \'The position of the transaction in the beacon block\' CODEC(DoubleDelta, ZSTD(1)),
    `hash` FixedString(66) COMMENT \'The hash of the transaction\' CODEC(ZSTD(1)),
    `from` FixedString(42) COMMENT \'The address of the account that sent the transaction\' CODEC(ZSTD(1)),
    `to` Nullable(FixedString(42)) COMMENT \'The address of the account that is the transaction recipient\' CODEC(ZSTD(1)),
    `nonce` UInt64 COMMENT \'The nonce of the sender account at the time of the transaction\' CODEC(ZSTD(1)),
    `gas_price` UInt128 COMMENT \'The gas price of the transaction in wei\' CODEC(ZSTD(1)),
    `gas` UInt64 COMMENT \'The maximum gas provided for the transaction execution\' CODEC(ZSTD(1)),
    `gas_tip_cap` Nullable(UInt128) COMMENT \'The priority fee (tip) the user has set for the transaction\' CODEC(ZSTD(1)),
    `gas_fee_cap` Nullable(UInt128) COMMENT \'The max fee the user has set for the transaction\' CODEC(ZSTD(1)),
    `value` UInt128 COMMENT \'The value transferred with the transaction in wei\' CODEC(ZSTD(1)),
    `type` UInt8 COMMENT \'The type of the transaction\' CODEC(ZSTD(1)),
    `size` UInt32 COMMENT \'The size of the transaction data in bytes\' CODEC(ZSTD(1)),
    `call_data_size` UInt32 COMMENT \'The size of the call data of the transaction in bytes\' CODEC(ZSTD(1)),
    `blob_gas` Nullable(UInt64) COMMENT \'The maximum gas provided for the blob transaction execution\' CODEC(ZSTD(1)),
    `blob_gas_fee_cap` Nullable(UInt128) COMMENT \'The max fee the user has set for the transaction\' CODEC(ZSTD(1)),
    `blob_hashes` Array(String) COMMENT \'The hashes of the blob commitments for blob transactions\' CODEC(ZSTD(1)),
    `blob_sidecars_size` Nullable(UInt32) COMMENT \'The total size of the sidecars for blob transactions in bytes\' CODEC(ZSTD(1)),
    `blob_sidecars_empty_size` Nullable(UInt32) COMMENT \'The total empty size of the sidecars for blob transactions in bytes\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, block_root, position, hash, nonce)
COMMENT 'Contains execution transaction from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `block_total_bytes` Nullable(UInt32) COMMENT \'The total bytes of the beacon block payload\' CODEC(ZSTD(1)),
    `block_total_bytes_compressed` Nullable(UInt32) COMMENT \'The total bytes of the beacon block payload when compressed using snappy\' CODEC(ZSTD(1)),
    `parent_root` FixedString(66) COMMENT \'The root hash of the parent beacon block\' CODEC(ZSTD(1)),
    `state_root` FixedString(66) COMMENT \'The root hash of the beacon state at this block\' CODEC(ZSTD(1)),
    `proposer_index` UInt32 COMMENT \'The index of the validator that proposed the beacon block\' CODEC(ZSTD(1)),
    `eth1_data_block_hash` FixedString(66) COMMENT \'The block hash of the associated execution block\' CODEC(ZSTD(1)),
    `eth1_data_deposit_root` FixedString(66) COMMENT \'The root of the deposit tree in the associated execution block\' CODEC(ZSTD(1)),
    `execution_payload_block_hash` Nullable(FixedString(66)) COMMENT \'The block hash of the execution payload\' CODEC(ZSTD(1)),
    `execution_payload_block_number` Nullable(UInt32) COMMENT \'The block number of the execution payload\' CODEC(DoubleDelta, ZSTD(1)),
    `execution_payload_fee_recipient` Nullable(String) COMMENT \'The recipient of the fee for this execution payload\' CODEC(ZSTD(1)),
    `execution_payload_base_fee_per_gas` Nullable(UInt128) COMMENT \'Base fee per gas for execution payload\' CODEC(ZSTD(1)),
    `execution_payload_blob_gas_used` Nullable(UInt64) COMMENT \'Gas used for blobs in execution payload\' CODEC(ZSTD(1)),
    `execution_payload_excess_blob_gas` Nullable(UInt64) COMMENT \'Excess gas used for blobs in execution payload\' CODEC(ZSTD(1)),
    `execution_payload_gas_limit` Nullable(UInt64) COMMENT \'Gas limit for execution payload\' CODEC(DoubleDelta, ZSTD(1)),
    `execution_payload_gas_used` Nullable(UInt64) COMMENT \'Gas used for execution payload\' CODEC(ZSTD(1)),
    `execution_payload_state_root` Nullable(FixedString(66)) COMMENT \'The state root of the execution payload\' CODEC(ZSTD(1)),
    `execution_payload_parent_hash` Nullable(FixedString(66)) COMMENT \'The parent hash of the execution payload\' CODEC(ZSTD(1)),
    `execution_payload_transactions_count` Nullable(UInt32) COMMENT \'The transaction count of the execution payload\' CODEC(ZSTD(1)),
    `execution_payload_transactions_total_bytes` Nullable(UInt32) COMMENT \'The transaction total bytes of the execution payload\' CODEC(ZSTD(1)),
    `execution_payload_transactions_total_bytes_compressed` Nullable(UInt32) COMMENT \'The transaction total bytes of the execution payload when compressed using snappy\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time)
COMMENT 'Contains beacon block from a beacon node.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_proposer_slashing_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `signed_header_1_message_slot` UInt32 COMMENT \'The slot number from the first signed header in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `signed_header_1_message_proposer_index` UInt32 COMMENT \'The proposer index from the first signed header in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `signed_header_1_message_body_root` FixedString(66) COMMENT \'The body root from the first signed header in the slashing payload\' CODEC(ZSTD(1)),
    `signed_header_1_message_parent_root` FixedString(66) COMMENT \'The parent root from the first signed header in the slashing payload\' CODEC(ZSTD(1)),
    `signed_header_1_message_state_root` FixedString(66) COMMENT \'The state root from the first signed header in the slashing payload\' CODEC(ZSTD(1)),
    `signed_header_1_signature` String COMMENT \'The signature for the first signed header in the slashing payload\' CODEC(ZSTD(1)),
    `signed_header_2_message_slot` UInt32 COMMENT \'The slot number from the second signed header in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `signed_header_2_message_proposer_index` UInt32 COMMENT \'The proposer index from the second signed header in the slashing payload\' CODEC(DoubleDelta, ZSTD(1)),
    `signed_header_2_message_body_root` FixedString(66) COMMENT \'The body root from the second signed header in the slashing payload\' CODEC(ZSTD(1)),
    `signed_header_2_message_parent_root` FixedString(66) COMMENT \'The parent root from the second signed header in the slashing payload\' CODEC(ZSTD(1)),
    `signed_header_2_message_state_root` FixedString(66) COMMENT \'The state root from the second signed header in the slashing payload\' CODEC(ZSTD(1)),
    `signed_header_2_signature` String COMMENT \'The signature for the second signed header in the slashing payload\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, block_root, signed_header_1_message_slot, signed_header_2_message_slot, signed_header_1_message_proposer_index, signed_header_2_message_proposer_index, signed_header_1_message_body_root, signed_header_2_message_body_root)
COMMENT 'Contains proposer slashing from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_sync_aggregate_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon chain\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon chain\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `sync_committee_period` UInt64 COMMENT \'The sync committee period number (epoch / 256)\' CODEC(DoubleDelta, ZSTD(1)),
    `sync_committee_bits` String COMMENT \'Raw 512-bit bitvector as hex string\' CODEC(ZSTD(1)),
    `sync_committee_signature` String COMMENT \'Aggregated signature from participating validators\' CODEC(ZSTD(1)),
    `validators_participated` Array(UInt32) COMMENT \'Validator indices that participated (voted)\' CODEC(ZSTD(1)),
    `validators_missed` Array(UInt32) COMMENT \'Validator indices that missed (did not vote)\' CODEC(ZSTD(1)),
    `participation_count` UInt16 COMMENT \'Number of validators that participated (0-512)\' CODEC(DoubleDelta, ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, slot)
COMMENT 'Contains canonical beacon block sync aggregate data with expanded validator participation.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_voluntary_exit_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `voluntary_exit_message_epoch` UInt32 COMMENT \'The epoch number from the exit message\' CODEC(DoubleDelta, ZSTD(1)),
    `voluntary_exit_message_validator_index` UInt32 COMMENT \'The validator index from the exit message\' CODEC(ZSTD(1)),
    `voluntary_exit_signature` String COMMENT \'The signature of the exit message\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, block_root, voluntary_exit_message_epoch, voluntary_exit_message_validator_index)
COMMENT 'Contains a voluntary exit from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_withdrawal_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root hash of the beacon block\' CODEC(ZSTD(1)),
    `block_version` LowCardinality(String) COMMENT \'The version of the beacon block\',
    `withdrawal_index` UInt32 COMMENT \'The index of the withdrawal\' CODEC(ZSTD(1)),
    `withdrawal_validator_index` UInt32 COMMENT \'The validator index from the withdrawal data\' CODEC(ZSTD(1)),
    `withdrawal_address` FixedString(42) COMMENT \'The address of the account that is the withdrawal recipient\' CODEC(ZSTD(1)),
    `withdrawal_amount` UInt128 COMMENT \'The amount of the withdrawal from the withdrawal data\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, block_root, withdrawal_index, withdrawal_validator_index)
COMMENT 'Contains a withdrawal from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_committee_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number in the beacon API committee payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `committee_index` LowCardinality(String) COMMENT \'The committee index in the beacon API committee payload\',
    `validators` Array(UInt32) COMMENT \'The validator indices in the beacon API committee payload\' CODEC(ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the beacon API committee payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, committee_index)
COMMENT 'Contains canonical beacon API /eth/v1/beacon/committees data.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_elaborated_attestation_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_slot` UInt32 COMMENT \'The slot number of the block containing the attestation\' CODEC(DoubleDelta, ZSTD(1)),
    `block_slot_start_date_time` DateTime COMMENT \'The wall clock time when the block slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_epoch` UInt32 COMMENT \'The epoch number of the block containing the attestation\' CODEC(DoubleDelta, ZSTD(1)),
    `block_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the block epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `position_in_block` UInt32 COMMENT \'The position of the attestation in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'The root of the block containing the attestation\' CODEC(ZSTD(1)),
    `validators` Array(UInt32) COMMENT \'Array of validator indices participating in the attestation\' CODEC(ZSTD(1)),
    `committee_index` LowCardinality(String) COMMENT \'The index of the committee making the attestation\',
    `beacon_block_root` FixedString(66) COMMENT \'The root of the beacon block being attested to\' CODEC(ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number being attested to\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `source_epoch` UInt32 COMMENT \'The source epoch referenced in the attestation\' CODEC(DoubleDelta, ZSTD(1)),
    `source_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the source epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `source_root` FixedString(66) COMMENT \'The root of the source checkpoint in the attestation\' CODEC(ZSTD(1)),
    `target_epoch` UInt32 COMMENT \'The target epoch referenced in the attestation\' CODEC(DoubleDelta, ZSTD(1)),
    `target_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the target epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `target_root` FixedString(66) COMMENT \'The root of the target checkpoint in the attestation\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, block_root, block_slot, position_in_block, beacon_block_root, slot, committee_index, source_root, target_root)
COMMENT 'Contains elaborated attestations from beacon blocks.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_proposer_duty_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'The slot number for which the proposer duty is assigned\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number containing the slot\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `proposer_validator_index` UInt32 COMMENT \'The validator index of the proposer for the slot\' CODEC(ZSTD(1)),
    `proposer_pubkey` String COMMENT \'The public key of the validator proposer\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, proposer_validator_index, proposer_pubkey)
COMMENT 'Contains a proposer duty from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_sync_committee_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event from a beacon node\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number for when the sync committee is active\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `sync_committee_period` UInt64 COMMENT \'The sync committee period number\' CODEC(DoubleDelta, ZSTD(1)),
    `validator_aggregates` Array(Array(UInt32)) COMMENT \'The validator indices grouped by subcommittee (64 groups of 8)\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(epoch_start_date_time))
ORDER BY (meta_network_name, epoch_start_date_time, sync_committee_period)
COMMENT 'Contains canonical beacon API /eth/v1/beacon/states/{state_id}/sync_committees data.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_validators_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `index` UInt32 COMMENT \'The index of the validator\' CODEC(DoubleDelta, ZSTD(1)),
    `balance` Nullable(UInt64) COMMENT \'The balance of the validator\' CODEC(T64, ZSTD(1)),
    `status` LowCardinality(String) COMMENT \'The status of the validator\',
    `effective_balance` Nullable(UInt64) COMMENT \'The effective balance of the validator\' CODEC(ZSTD(1)),
    `slashed` Bool COMMENT \'Whether the validator is slashed\',
    `activation_epoch` Nullable(UInt64) COMMENT \'The epoch when the validator was activated\' CODEC(ZSTD(1)),
    `activation_eligibility_epoch` Nullable(UInt64) COMMENT \'The epoch when the validator was activated\' CODEC(ZSTD(1)),
    `exit_epoch` Nullable(UInt64) COMMENT \'The epoch when the validator exited\' CODEC(ZSTD(1)),
    `withdrawable_epoch` Nullable(UInt64) COMMENT \'The epoch when the validator can withdraw\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(epoch_start_date_time))
ORDER BY (meta_network_name, epoch_start_date_time, index, status)
COMMENT 'Contains a validator state for an epoch.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_validators_pubkeys_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `index` UInt32 COMMENT \'The index of the validator\' CODEC(ZSTD(1)),
    `pubkey` String COMMENT \'The public key of the validator\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY meta_network_name
ORDER BY (meta_network_name, index, pubkey)
COMMENT 'Contains a validator state for an epoch.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_validators_withdrawal_credentials_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number from beacon block payload\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `index` UInt32 COMMENT \'The index of the validator\' CODEC(ZSTD(1)),
    `withdrawal_credentials` String COMMENT \'The withdrawal credentials of the validator\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_consensus_version` LowCardinality(String) COMMENT \'Ethereum consensus client version that generated the event\',
    `meta_consensus_version_major` LowCardinality(String) COMMENT \'Ethereum consensus client major version that generated the event\',
    `meta_consensus_version_minor` LowCardinality(String) COMMENT \'Ethereum consensus client minor version that generated the event\',
    `meta_consensus_version_patch` LowCardinality(String) COMMENT \'Ethereum consensus client patch version that generated the event\',
    `meta_consensus_implementation` LowCardinality(String) COMMENT \'Ethereum consensus client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY meta_network_name
ORDER BY (meta_network_name, index, withdrawal_credentials)
COMMENT 'Contains a validator state for an epoch.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_address_appearances_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash that caused the address appearance\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the address appearance within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `address` String COMMENT \'The address of the address appearance\' CODEC(ZSTD(1)),
    `relationship` LowCardinality(String) COMMENT \'The relationship of the address to the transaction\',
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution address appearance data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_balance_diffs_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash that caused the balance diff\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the balance diff within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `address` String COMMENT \'The address of the balance diff\' CODEC(ZSTD(1)),
    `from_value` UInt256 COMMENT \'The from value of the balance diff\' CODEC(ZSTD(1)),
    `to_value` UInt256 COMMENT \'The to value of the balance diff\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution balance diff data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_balance_reads_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash that caused the balance read\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the balance read within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `address` String COMMENT \'The address of the balance read\' CODEC(ZSTD(1)),
    `balance` UInt256 COMMENT \'The balance that was read\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution balance read data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_block_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_date_time` DateTime64(3) COMMENT \'The block timestamp\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `block_hash` FixedString(66) COMMENT \'The block hash\' CODEC(ZSTD(1)),
    `author` Nullable(String) COMMENT \'The block author\' CODEC(ZSTD(1)),
    `gas_used` Nullable(UInt64) COMMENT \'The block gas used\' CODEC(DoubleDelta, ZSTD(1)),
    `gas_limit` UInt64 COMMENT \'The block gas limit\' CODEC(DoubleDelta, ZSTD(1)),
    `extra_data` Nullable(String) COMMENT \'The block extra data in hex\' CODEC(ZSTD(1)),
    `extra_data_string` Nullable(String) COMMENT \'The block extra data in UTF-8 string\' CODEC(ZSTD(1)),
    `base_fee_per_gas` Nullable(UInt64) COMMENT \'The block base fee per gas\' CODEC(DoubleDelta, ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number)
COMMENT 'Contains canonical execution block data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_contracts_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash that created the contract\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the contract creation within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `create_index` UInt32 COMMENT \'The create index\' CODEC(DoubleDelta, ZSTD(1)),
    `contract_address` String COMMENT \'The contract address\' CODEC(ZSTD(1)),
    `deployer` String COMMENT \'The address of the contract deployer\' CODEC(ZSTD(1)),
    `factory` String COMMENT \'The address of the factory that deployed the contract\' CODEC(ZSTD(1)),
    `init_code` String COMMENT \'The initialization code of the contract\' CODEC(ZSTD(1)),
    `code` Nullable(String) COMMENT \'The code of the contract\' CODEC(ZSTD(1)),
    `init_code_hash` String COMMENT \'The hash of the initialization code\' CODEC(ZSTD(1)),
    `n_init_code_bytes` UInt32 COMMENT \'Number of bytes in the initialization code\' CODEC(DoubleDelta, ZSTD(1)),
    `n_code_bytes` UInt32 COMMENT \'Number of bytes in the contract code\' CODEC(DoubleDelta, ZSTD(1)),
    `code_hash` String COMMENT \'The hash of the contract code\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution contract data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_erc20_transfers_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the transfer within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `log_index` UInt64 COMMENT \'The log index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `erc20` String COMMENT \'The erc20 address\' CODEC(ZSTD(1)),
    `from_address` String COMMENT \'The from address\' CODEC(ZSTD(1)),
    `to_address` String COMMENT \'The to address\' CODEC(ZSTD(1)),
    `value` UInt256 COMMENT \'The value of the transfer\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution erc20 transfer data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_erc721_transfers_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the transfer within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `log_index` UInt64 COMMENT \'The log index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `erc721` String COMMENT \'The erc20 address\' CODEC(ZSTD(1)),
    `from_address` String COMMENT \'The from address\' CODEC(ZSTD(1)),
    `to_address` String COMMENT \'The to address\' CODEC(ZSTD(1)),
    `token` UInt256 COMMENT \'The token id\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution erc721 transfer data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_four_byte_counts_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash\' CODEC(ZSTD(1)),
    `signature` String COMMENT \'The signature of the four byte count\' CODEC(ZSTD(1)),
    `size` UInt64 COMMENT \'The size of the four byte count\' CODEC(ZSTD(1)),
    `count` UInt64 COMMENT \'The count of the four byte count\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash)
COMMENT 'Contains canonical execution four byte count data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_logs_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash associated with the log\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the log within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `log_index` UInt32 COMMENT \'The log index within the block\' CODEC(DoubleDelta, ZSTD(1)),
    `address` String COMMENT \'The address associated with the log\' CODEC(ZSTD(1)),
    `topic0` String COMMENT \'The first topic of the log\' CODEC(ZSTD(1)),
    `topic1` Nullable(String) COMMENT \'The second topic of the log\' CODEC(ZSTD(1)),
    `topic2` Nullable(String) COMMENT \'The third topic of the log\' CODEC(ZSTD(1)),
    `topic3` Nullable(String) COMMENT \'The fourth topic of the log\' CODEC(ZSTD(1)),
    `data` Nullable(String) COMMENT \'The data associated with the log\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution logs data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_native_transfers_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the transfer within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `transfer_index` UInt64 COMMENT \'The transfer index\' CODEC(DoubleDelta, ZSTD(1)),
    `from_address` String COMMENT \'The from address\' CODEC(ZSTD(1)),
    `to_address` String COMMENT \'The to address\' CODEC(ZSTD(1)),
    `value` UInt256 COMMENT \'The value of the approval\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution native transfer data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_nonce_diffs_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash that caused the nonce diff\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the nonce diff within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `address` String COMMENT \'The address of the nonce diff\' CODEC(ZSTD(1)),
    `from_value` UInt64 COMMENT \'The from value of the nonce diff\' CODEC(ZSTD(1)),
    `to_value` UInt64 COMMENT \'The to value of the nonce diff\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution nonce diff data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_nonce_reads_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash that caused the nonce read\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the nonce read within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `address` String COMMENT \'The address of the nonce read\' CODEC(ZSTD(1)),
    `nonce` UInt64 COMMENT \'The nonce that was read\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution nonce read data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_storage_diffs_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash associated with the storage diff\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the storage diff within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `address` String COMMENT \'The address associated with the storage diff\' CODEC(ZSTD(1)),
    `slot` String COMMENT \'The storage slot key\' CODEC(ZSTD(1)),
    `from_value` String COMMENT \'The original value before the storage diff\' CODEC(ZSTD(1)),
    `to_value` String COMMENT \'The new value after the storage diff\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution storage diffs data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_storage_reads_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash associated with the storage read\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the storage read within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `contract_address` String COMMENT \'The contract address associated with the storage read\' CODEC(ZSTD(1)),
    `slot` String COMMENT \'The storage slot key\' CODEC(ZSTD(1)),
    `value` String COMMENT \'The value read from the storage slot\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution storage reads data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_traces_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash\' CODEC(ZSTD(1)),
    `internal_index` UInt32 COMMENT \'The internal index of the trace within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `action_from` String COMMENT \'The from address of the action\' CODEC(ZSTD(1)),
    `action_to` Nullable(String) COMMENT \'The to address of the action\' CODEC(ZSTD(1)),
    `action_value` UInt256 COMMENT \'The value of the action\' CODEC(ZSTD(1)),
    `action_gas` UInt64 COMMENT \'The gas provided for the action\' CODEC(DoubleDelta, ZSTD(1)),
    `action_input` Nullable(String) COMMENT \'The input data for the action\' CODEC(ZSTD(1)),
    `action_call_type` LowCardinality(String) COMMENT \'The call type of the action\' CODEC(ZSTD(1)),
    `action_init` Nullable(String) COMMENT \'The initialization code for the action\' CODEC(ZSTD(1)),
    `action_reward_type` String COMMENT \'The reward type for the action\' CODEC(ZSTD(1)),
    `action_type` LowCardinality(String) COMMENT \'The type of the action\' CODEC(ZSTD(1)),
    `result_gas_used` UInt64 COMMENT \'The gas used in the result\' CODEC(DoubleDelta, ZSTD(1)),
    `result_output` Nullable(String) COMMENT \'The output of the result\' CODEC(ZSTD(1)),
    `result_code` Nullable(String) COMMENT \'The code returned in the result\' CODEC(ZSTD(1)),
    `result_address` Nullable(String) COMMENT \'The address returned in the result\' CODEC(ZSTD(1)),
    `trace_address` Nullable(String) COMMENT \'The trace address\' CODEC(ZSTD(1)),
    `subtraces` UInt32 COMMENT \'The number of subtraces\' CODEC(DoubleDelta, ZSTD(1)),
    `error` Nullable(String) COMMENT \'The error, if any, in the trace\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash, internal_index)
COMMENT 'Contains canonical execution traces data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_transaction_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction index\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash\' CODEC(ZSTD(1)),
    `nonce` UInt64 COMMENT \'The transaction nonce\' CODEC(ZSTD(1)),
    `from_address` String COMMENT \'The transaction from address\' CODEC(ZSTD(1)),
    `to_address` Nullable(String) COMMENT \'The transaction to address\' CODEC(ZSTD(1)),
    `value` UInt256 COMMENT \'The transaction value in float64\' CODEC(ZSTD(1)),
    `input` Nullable(String) COMMENT \'The transaction input in hex\' CODEC(ZSTD(1)),
    `gas_limit` UInt64 COMMENT \'The transaction gas limit\' CODEC(ZSTD(1)),
    `gas_used` UInt64 COMMENT \'The transaction gas used\' CODEC(ZSTD(1)),
    `gas_price` UInt128 COMMENT \'The transaction gas price\' CODEC(ZSTD(1)),
    `transaction_type` UInt8 COMMENT \'The transaction type\' CODEC(ZSTD(1)),
    `max_priority_fee_per_gas` UInt64 COMMENT \'The transaction max priority fee per gas\' CODEC(ZSTD(1)),
    `max_fee_per_gas` UInt64 COMMENT \'The transaction max fee per gas\' CODEC(ZSTD(1)),
    `success` Bool COMMENT \'The transaction success\' CODEC(ZSTD(1)),
    `n_input_bytes` UInt32 COMMENT \'The transaction input bytes\' CODEC(ZSTD(1)),
    `n_input_zero_bytes` UInt32 COMMENT \'The transaction input zero bytes\' CODEC(ZSTD(1)),
    `n_input_nonzero_bytes` UInt32 COMMENT \'The transaction input nonzero bytes\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, transaction_hash)
COMMENT 'Contains canonical execution transaction data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_transaction_structlog_agg_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash\' CODEC(ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction position in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `call_frame_id` UInt32 COMMENT \'Sequential frame ID within the transaction (0=root)\' CODEC(DoubleDelta, ZSTD(1)),
    `parent_call_frame_id` Nullable(UInt32) COMMENT \'Parent frame ID (NULL for root frame)\' CODEC(ZSTD(1)),
    `call_frame_path` Array(UInt32) COMMENT \'Path of frame IDs from root to current frame\' CODEC(ZSTD(1)),
    `depth` UInt32 COMMENT \'Call nesting depth (0=root)\' CODEC(DoubleDelta, ZSTD(1)),
    `target_address` Nullable(String) COMMENT \'Contract address being called\' CODEC(ZSTD(1)),
    `call_type` LowCardinality(String) COMMENT \'Call type: CALL/DELEGATECALL/STATICCALL/CALLCODE/CREATE/CREATE2 (empty for root)\',
    `operation` LowCardinality(String) COMMENT \'Opcode name for per-opcode rows, empty string for frame summary rows\',
    `opcode_count` UInt64 COMMENT \'Number of opcodes (total for summary row, count for per-opcode row)\' CODEC(ZSTD(1)),
    `error_count` UInt64 COMMENT \'Number of errors\' CODEC(ZSTD(1)),
    `gas` UInt64 COMMENT \'Gas consumed: SUM(gas_self) for per-opcode, frame self gas for summary\' CODEC(ZSTD(1)),
    `gas_cumulative` UInt64 COMMENT \'Cumulative gas: SUM(gas_used) for per-opcode, frame total for summary\' CODEC(ZSTD(1)),
    `min_depth` UInt32 COMMENT \'Minimum depth where opcode appeared (per-opcode rows)\' CODEC(DoubleDelta, ZSTD(1)),
    `max_depth` UInt32 COMMENT \'Maximum depth where opcode appeared (per-opcode rows)\' CODEC(DoubleDelta, ZSTD(1)),
    `memory_words_sum_before` UInt64 DEFAULT 0 COMMENT \'SUM(ceil(memory_bytes/32)) before each opcode executes. Used with sq_sum to compute memory expansion gas.\' CODEC(ZSTD(1)),
    `memory_words_sum_after` UInt64 DEFAULT 0 COMMENT \'SUM(ceil(memory_bytes/32)) after each opcode executes.\' CODEC(ZSTD(1)),
    `memory_words_sq_sum_before` UInt64 DEFAULT 0 COMMENT \'SUM(words_before). With sum_before, enables exact memory gas via E[cost(after)] - E[cost(before)].\' CODEC(ZSTD(1)),
    `memory_words_sq_sum_after` UInt64 DEFAULT 0 COMMENT \'SUM(words_after). With sum_after, enables exact memory gas via E[cost(after)] - E[cost(before)].\' CODEC(ZSTD(1)),
    `memory_expansion_gas` UInt64 DEFAULT 0 COMMENT \'SUM(memory_expansion_gas). Exact per-opcode memory expansion cost, pre-computed to avoid intDiv rounding in SQL reconstruction.\' CODEC(ZSTD(1)),
    `cold_access_count` UInt64 DEFAULT 0 COMMENT \'Number of cold storage/account accesses (EIP-2929). cold_gas = cold_count * (cold_cost - warm_cost).\' CODEC(ZSTD(1)),
    `gas_refund` Nullable(UInt64) COMMENT \'Gas refund (root summary row only)\' CODEC(ZSTD(1)),
    `intrinsic_gas` Nullable(UInt64) COMMENT \'Intrinsic gas (root summary row only, computed)\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 201600))
ORDER BY (meta_network_name, block_number, transaction_hash, call_frame_id, operation)
COMMENT 'Aggregated EVM execution data. Summary rows (operation="") contain frame metadata. Per-opcode rows contain aggregated gas/count per (frame, opcode).';

CREATE TABLE IF NOT EXISTS default.canonical_execution_transaction_structlog_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_hash` FixedString(66) COMMENT \'The transaction hash\' CODEC(ZSTD(1)),
    `transaction_index` UInt64 COMMENT \'The transaction position in the block\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_gas` UInt64 COMMENT \'The transaction gas\' CODEC(DoubleDelta, ZSTD(1)),
    `transaction_failed` Bool COMMENT \'The transaction failed\' CODEC(ZSTD(1)),
    `transaction_return_value` Nullable(String) COMMENT \'The transaction return value\' CODEC(ZSTD(1)),
    `index` UInt32 COMMENT \'The index of this structlog in this transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `operation` LowCardinality(String) COMMENT \'The operation\',
    `gas` UInt64 COMMENT \'The gas\' CODEC(Delta(8), ZSTD(1)),
    `gas_cost` UInt64 COMMENT \'The gas cost\' CODEC(DoubleDelta, ZSTD(1)),
    `gas_used` UInt64 DEFAULT 0 COMMENT \'Actual gas consumed (computed from consecutive gas values)\' CODEC(ZSTD(1)),
    `gas_self` UInt64 DEFAULT 0 COMMENT \'Gas consumed by this opcode only, excludes child frame gas for CALL/CREATE opcodes. sum(gas_self) = total execution gas without double counting\' CODEC(ZSTD(1)),
    `depth` UInt64 COMMENT \'The depth\' CODEC(DoubleDelta, ZSTD(1)),
    `return_data` Nullable(String) COMMENT \'The return data\' CODEC(ZSTD(1)),
    `refund` Nullable(UInt64) COMMENT \'The refund\' CODEC(ZSTD(1)),
    `error` Nullable(String) COMMENT \'The error\' CODEC(ZSTD(1)),
    `call_to_address` Nullable(String) COMMENT \'Address of a CALL operation\' CODEC(ZSTD(1)),
    `call_frame_id` UInt32 DEFAULT 0 COMMENT \'Sequential identifier for the call frame within the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `call_frame_path` Array(UInt32) DEFAULT [0] COMMENT \'Path of frame IDs from root to current frame\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 201600))
ORDER BY (meta_network_name, block_number, transaction_hash, index)
COMMENT 'Contains canonical execution transaction structlog data.';

CREATE TABLE IF NOT EXISTS default.consensus_engine_api_get_blobs_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event\' CODEC(DoubleDelta, ZSTD(1)),
    `requested_date_time` DateTime64(3) COMMENT \'Timestamp when the engine_getBlobs call was initiated\' CODEC(DoubleDelta, ZSTD(1)),
    `duration_ms` UInt64 COMMENT \'How long the engine_getBlobs call took in milliseconds\' CODEC(ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number of the beacon block being reconstructed\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number derived from the slot\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'Root of the beacon block (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `parent_block_root` FixedString(66) COMMENT \'Root of the parent beacon block (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `requested_count` UInt32 COMMENT \'Number of versioned hashes requested\' CODEC(ZSTD(1)),
    `versioned_hashes` Array(FixedString(66)) COMMENT \'List of versioned hashes requested (derived from KZG commitments)\' CODEC(ZSTD(1)),
    `returned_count` UInt32 COMMENT \'Number of non-null blobs returned\' CODEC(ZSTD(1)),
    `status` LowCardinality(String) COMMENT \'Result status (SUCCESS, PARTIAL, EMPTY, UNSUPPORTED, ERROR)\',
    `error_message` Nullable(String) COMMENT \'Error details if status is ERROR or UNSUPPORTED\' CODEC(ZSTD(1)),
    `method_version` LowCardinality(String) COMMENT \'Version of the engine_getBlobs method (e.g., V1, V2)\',
    `meta_execution_version` LowCardinality(String) COMMENT \'Full execution client version string from web3_clientVersion RPC\',
    `meta_execution_implementation` LowCardinality(String) COMMENT \'Execution client implementation name (e.g., Geth, Nethermind, Besu, Reth, Erigon)\',
    `meta_execution_version_major` LowCardinality(String) COMMENT \'Execution client major version number\',
    `meta_execution_version_minor` LowCardinality(String) COMMENT \'Execution client minor version number\',
    `meta_execution_version_patch` LowCardinality(String) COMMENT \'Execution client patch version number\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, block_root, event_date_time)
COMMENT 'Contains timing and instrumentation data for engine_getBlobs calls between the consensus and execution layer.';

CREATE TABLE IF NOT EXISTS default.consensus_engine_api_new_payload_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the sentry received the event\' CODEC(DoubleDelta, ZSTD(1)),
    `requested_date_time` DateTime64(3) COMMENT \'Timestamp when the engine_newPayload call was initiated\' CODEC(DoubleDelta, ZSTD(1)),
    `duration_ms` UInt64 COMMENT \'How long the engine_newPayload call took in milliseconds\' CODEC(ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number of the beacon block containing the payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number derived from the slot\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `block_root` FixedString(66) COMMENT \'Root of the beacon block (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `parent_block_root` FixedString(66) COMMENT \'Root of the parent beacon block (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `proposer_index` UInt32 COMMENT \'Validator index of the block proposer\' CODEC(ZSTD(1)),
    `block_number` UInt64 COMMENT \'Execution block number\' CODEC(DoubleDelta, ZSTD(1)),
    `block_hash` FixedString(66) COMMENT \'Execution block hash (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `parent_hash` FixedString(66) COMMENT \'Parent execution block hash (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `gas_used` UInt64 COMMENT \'Total gas used by all transactions in the block\' CODEC(ZSTD(1)),
    `gas_limit` UInt64 COMMENT \'Gas limit of the block\' CODEC(ZSTD(1)),
    `tx_count` UInt32 COMMENT \'Number of transactions in the block\' CODEC(ZSTD(1)),
    `blob_count` UInt32 COMMENT \'Number of blobs in the block\' CODEC(ZSTD(1)),
    `status` LowCardinality(String) COMMENT \'Payload status returned by EL (VALID, INVALID, SYNCING, ACCEPTED, INVALID_BLOCK_HASH)\',
    `latest_valid_hash` Nullable(FixedString(66)) COMMENT \'Latest valid hash when status is INVALID (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `validation_error` Nullable(String) COMMENT \'Error message when validation fails\' CODEC(ZSTD(1)),
    `method_version` LowCardinality(String) COMMENT \'Version of the engine_newPayload method (e.g., V3, V4)\',
    `meta_execution_version` LowCardinality(String),
    `meta_execution_implementation` LowCardinality(String) DEFAULT \'\' COMMENT \'Execution client implementation name (e.g., Geth, Nethermind, Besu, Reth, Erigon)\',
    `meta_execution_version_major` LowCardinality(String) DEFAULT \'\' COMMENT \'Execution client major version number\',
    `meta_execution_version_minor` LowCardinality(String) DEFAULT \'\' COMMENT \'Execution client minor version number\',
    `meta_execution_version_patch` LowCardinality(String) DEFAULT \'\' COMMENT \'Execution client patch version number\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, block_hash, event_date_time)
COMMENT 'Contains timing and instrumentation data for engine_newPayload calls between the consensus and execution layer.';

CREATE TABLE IF NOT EXISTS default.ethseer_validator_entity_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the client fetched the beacon block from ethseer.io\' CODEC(DoubleDelta, ZSTD(1)),
    `index` UInt32 COMMENT \'The index of the validator\' CODEC(DoubleDelta, ZSTD(1)),
    `pubkey` String COMMENT \'The public key of the validator\' CODEC(ZSTD(1)),
    `entity` String COMMENT \'The entity of the validator\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY meta_network_name
ORDER BY (meta_network_name, index, pubkey)
COMMENT 'Contains a mapping of validators to entities';

CREATE TABLE IF NOT EXISTS default.execution_block_metrics_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `source` LowCardinality(String) COMMENT \'Data source (e.g., client-logs)\',
    `block_number` UInt64 COMMENT \'Execution block number\' CODEC(DoubleDelta, ZSTD(1)),
    `block_hash` FixedString(66) COMMENT \'Execution block hash (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `gas_used` UInt64 COMMENT \'Total gas used by all transactions in the block\' CODEC(ZSTD(1)),
    `tx_count` UInt32 COMMENT \'Number of transactions in the block\' CODEC(ZSTD(1)),
    `execution_ms` Float64 COMMENT \'Time spent executing transactions in milliseconds\' CODEC(ZSTD(1)),
    `state_read_ms` Float64 COMMENT \'Time spent reading state in milliseconds\' CODEC(ZSTD(1)),
    `state_hash_ms` Float64 COMMENT \'Time spent computing state hash in milliseconds\' CODEC(ZSTD(1)),
    `commit_ms` Float64 COMMENT \'Time spent committing state changes in milliseconds\' CODEC(ZSTD(1)),
    `total_ms` Float64 COMMENT \'Total time for block processing in milliseconds\' CODEC(ZSTD(1)),
    `mgas_per_sec` Float64 COMMENT \'Throughput in million gas per second\' CODEC(ZSTD(1)),
    `state_reads_accounts` UInt64 COMMENT \'Number of account reads\' CODEC(ZSTD(1)),
    `state_reads_storage_slots` UInt64 COMMENT \'Number of storage slot reads\' CODEC(ZSTD(1)),
    `state_reads_code` UInt64 COMMENT \'Number of code reads\' CODEC(ZSTD(1)),
    `state_reads_code_bytes` UInt64 COMMENT \'Total bytes of code read\' CODEC(ZSTD(1)),
    `state_writes_accounts` UInt64 COMMENT \'Number of account writes\' CODEC(ZSTD(1)),
    `state_writes_accounts_deleted` UInt64 COMMENT \'Number of accounts deleted\' CODEC(ZSTD(1)),
    `state_writes_storage_slots` UInt64 COMMENT \'Number of storage slot writes\' CODEC(ZSTD(1)),
    `state_writes_storage_slots_deleted` UInt64 COMMENT \'Number of storage slots deleted\' CODEC(ZSTD(1)),
    `state_writes_code` UInt64 COMMENT \'Number of code writes\' CODEC(ZSTD(1)),
    `state_writes_code_bytes` UInt64 COMMENT \'Total bytes of code written\' CODEC(ZSTD(1)),
    `account_cache_hits` Int64 COMMENT \'Number of account cache hits\' CODEC(ZSTD(1)),
    `account_cache_misses` Int64 COMMENT \'Number of account cache misses\' CODEC(ZSTD(1)),
    `account_cache_hit_rate` Float64 COMMENT \'Account cache hit rate as percentage\' CODEC(ZSTD(1)),
    `storage_cache_hits` Int64 COMMENT \'Number of storage cache hits\' CODEC(ZSTD(1)),
    `storage_cache_misses` Int64 COMMENT \'Number of storage cache misses\' CODEC(ZSTD(1)),
    `storage_cache_hit_rate` Float64 COMMENT \'Storage cache hit rate as percentage\' CODEC(ZSTD(1)),
    `code_cache_hits` Int64 COMMENT \'Number of code cache hits\' CODEC(ZSTD(1)),
    `code_cache_misses` Int64 COMMENT \'Number of code cache misses\' CODEC(ZSTD(1)),
    `code_cache_hit_rate` Float64 COMMENT \'Code cache hit rate as percentage\' CODEC(ZSTD(1)),
    `code_cache_hit_bytes` Int64 COMMENT \'Total bytes of code cache hits\' CODEC(ZSTD(1)),
    `code_cache_miss_bytes` Int64 COMMENT \'Total bytes of code cache misses\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, meta_client_name, event_date_time)
COMMENT 'Contains detailed performance metrics from execution client structured logging for block execution';

CREATE TABLE IF NOT EXISTS default.execution_engine_get_blobs_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `requested_date_time` DateTime64(3) COMMENT \'Timestamp when the engine_getBlobs call was received\' CODEC(DoubleDelta, ZSTD(1)),
    `duration_ms` UInt64 COMMENT \'How long the engine_getBlobs call took in milliseconds\' CODEC(ZSTD(1)),
    `source` LowCardinality(String) COMMENT \'Source of the event (SNOOPER, EXECUTION_CLIENT)\',
    `requested_count` UInt32 COMMENT \'Number of versioned hashes requested\' CODEC(ZSTD(1)),
    `versioned_hashes` Array(FixedString(66)) COMMENT \'List of versioned hashes requested (hex encoded)\' CODEC(ZSTD(1)),
    `returned_count` UInt32 COMMENT \'Number of non-null blobs returned\' CODEC(ZSTD(1)),
    `returned_blob_indexes` Array(UInt8) COMMENT \'Indexes (0-based) of the requested versioned_hashes that were successfully returned\',
    `status` LowCardinality(String) COMMENT \'Result status (SUCCESS, PARTIAL, EMPTY, UNSUPPORTED, ERROR)\',
    `error_message` Nullable(String) COMMENT \'Error details if status is ERROR or UNSUPPORTED\' CODEC(ZSTD(1)),
    `method_version` LowCardinality(String) COMMENT \'Version of the engine_getBlobs method (e.g., V1, V2)\',
    `meta_execution_implementation` LowCardinality(String) COMMENT \'Implementation of the execution client (e.g., go-ethereum, reth, nethermind)\',
    `meta_execution_version` LowCardinality(String) COMMENT \'Version of the execution client\',
    `meta_execution_version_major` LowCardinality(String) COMMENT \'Major version number of the execution client\',
    `meta_execution_version_minor` LowCardinality(String) COMMENT \'Minor version number of the execution client\',
    `meta_execution_version_patch` LowCardinality(String) COMMENT \'Patch version number of the execution client\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name)
COMMENT 'Contains timing and instrumentation data for engine_getBlobs calls from the execution layer perspective.';

CREATE TABLE IF NOT EXISTS default.execution_engine_new_payload_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `requested_date_time` DateTime64(3) COMMENT \'Timestamp when the engine_newPayload call was received\' CODEC(DoubleDelta, ZSTD(1)),
    `duration_ms` UInt64 COMMENT \'How long the engine_newPayload call took in milliseconds\' CODEC(ZSTD(1)),
    `source` LowCardinality(String) COMMENT \'Source of the event (SNOOPER, EXECUTION_CLIENT)\',
    `block_number` UInt64 COMMENT \'Execution block number\' CODEC(DoubleDelta, ZSTD(1)),
    `block_hash` FixedString(66) COMMENT \'Execution block hash (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `parent_hash` FixedString(66) COMMENT \'Parent execution block hash (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `gas_used` UInt64 COMMENT \'Total gas used by all transactions in the block\' CODEC(ZSTD(1)),
    `gas_limit` UInt64 COMMENT \'Gas limit of the block\' CODEC(ZSTD(1)),
    `tx_count` UInt32 COMMENT \'Number of transactions in the block\' CODEC(ZSTD(1)),
    `blob_count` UInt32 COMMENT \'Number of blobs in the block\' CODEC(ZSTD(1)),
    `status` LowCardinality(String) COMMENT \'Payload status returned (VALID, INVALID, SYNCING, ACCEPTED, INVALID_BLOCK_HASH)\',
    `latest_valid_hash` Nullable(FixedString(66)) COMMENT \'Latest valid hash when status is INVALID (hex encoded with 0x prefix)\' CODEC(ZSTD(1)),
    `validation_error` Nullable(String) COMMENT \'Error message when validation fails\' CODEC(ZSTD(1)),
    `method_version` LowCardinality(String) COMMENT \'Version of the engine_newPayload method (e.g., V3, V4)\',
    `meta_execution_implementation` LowCardinality(String) COMMENT \'Implementation of the execution client (e.g., go-ethereum, reth, nethermind)\',
    `meta_execution_version` LowCardinality(String) COMMENT \'Version of the execution client\',
    `meta_execution_version_major` LowCardinality(String) COMMENT \'Major version number of the execution client\',
    `meta_execution_version_minor` LowCardinality(String) COMMENT \'Minor version number of the execution client\',
    `meta_execution_version_patch` LowCardinality(String) COMMENT \'Patch version number of the execution client\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, meta_client_name, block_hash, event_date_time)
COMMENT 'Contains timing and instrumentation data for engine_newPayload calls from the execution layer perspective.';

CREATE TABLE IF NOT EXISTS default.execution_state_size_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the state size measurement was taken\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'Block number at which the state size was measured\' CODEC(DoubleDelta, ZSTD(1)),
    `state_root` FixedString(66) COMMENT \'State root hash of the execution layer at this block\' CODEC(ZSTD(1)),
    `accounts` UInt64 COMMENT \'Total number of accounts in the state\' CODEC(ZSTD(1)),
    `account_bytes` UInt64 COMMENT \'Total bytes used by account data\' CODEC(ZSTD(1)),
    `account_trienodes` UInt64 COMMENT \'Number of trie nodes in the account trie\' CODEC(ZSTD(1)),
    `account_trienode_bytes` UInt64 COMMENT \'Total bytes used by account trie nodes\' CODEC(ZSTD(1)),
    `contract_codes` UInt64 COMMENT \'Total number of contract codes stored\' CODEC(ZSTD(1)),
    `contract_code_bytes` UInt64 COMMENT \'Total bytes used by contract code\' CODEC(ZSTD(1)),
    `storages` UInt64 COMMENT \'Total number of storage slots in the state\' CODEC(ZSTD(1)),
    `storage_bytes` UInt64 COMMENT \'Total bytes used by storage data\' CODEC(ZSTD(1)),
    `storage_trienodes` UInt64 COMMENT \'Number of trie nodes in the storage trie\' CODEC(ZSTD(1)),
    `storage_trienode_bytes` UInt64 COMMENT \'Total bytes used by storage trie nodes\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_execution_version` LowCardinality(String) COMMENT \'Execution client version that generated the event\',
    `meta_execution_version_major` LowCardinality(String) COMMENT \'Execution client major version that generated the event\',
    `meta_execution_version_minor` LowCardinality(String) COMMENT \'Execution client minor version that generated the event\',
    `meta_execution_version_patch` LowCardinality(String) COMMENT \'Execution client patch version that generated the event\',
    `meta_execution_implementation` LowCardinality(String) COMMENT \'Execution client implementation that generated the event\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, meta_client_name, state_root, event_date_time)
COMMENT 'Contains execution layer state size metrics including account, contract code, and storage data measurements at specific block heights.';

CREATE TABLE IF NOT EXISTS default.execution_transaction_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `block_hash` FixedString(66) COMMENT \'The block hash\' CODEC(ZSTD(1)),
    `parent_hash` FixedString(66) COMMENT \'The parent block hash\' CODEC(ZSTD(1)),
    `position` UInt32 COMMENT \'The position of the transaction in the beacon block\' CODEC(DoubleDelta, ZSTD(1)),
    `hash` FixedString(66) COMMENT \'The hash of the transaction\' CODEC(ZSTD(1)),
    `from` FixedString(42) COMMENT \'The address of the account that sent the transaction\' CODEC(ZSTD(1)),
    `to` Nullable(FixedString(42)) COMMENT \'The address of the account that is the transaction recipient\' CODEC(ZSTD(1)),
    `nonce` UInt64 COMMENT \'The nonce of the sender account at the time of the transaction\' CODEC(ZSTD(1)),
    `gas_price` UInt128 COMMENT \'The gas price of the transaction in wei\' CODEC(ZSTD(1)),
    `gas` UInt64 COMMENT \'The maximum gas provided for the transaction execution\' CODEC(ZSTD(1)),
    `gas_tip_cap` Nullable(UInt128) COMMENT \'The priority fee (tip) the user has set for the transaction\' CODEC(ZSTD(1)),
    `gas_fee_cap` Nullable(UInt128) COMMENT \'The max fee the user has set for the transaction\' CODEC(ZSTD(1)),
    `value` UInt128 COMMENT \'The value transferred with the transaction in wei\' CODEC(ZSTD(1)),
    `type` UInt8 COMMENT \'The type of the transaction\' CODEC(ZSTD(1)),
    `size` UInt32 COMMENT \'The size of the transaction data in bytes\' CODEC(ZSTD(1)),
    `call_data_size` UInt32 COMMENT \'The size of the call data of the transaction in bytes\' CODEC(ZSTD(1)),
    `blob_gas` Nullable(UInt64) COMMENT \'The maximum gas provided for the blob transaction execution\' CODEC(ZSTD(1)),
    `blob_gas_fee_cap` Nullable(UInt128) COMMENT \'The max fee the user has set for the transaction\' CODEC(ZSTD(1)),
    `blob_hashes` Array(String) COMMENT \'The hashes of the blob commitments for blob transactions\' CODEC(ZSTD(1)),
    `success` Bool COMMENT \'The transaction success\' CODEC(ZSTD(1)),
    `n_input_bytes` UInt32 COMMENT \'The transaction input bytes\' CODEC(ZSTD(1)),
    `n_input_zero_bytes` UInt32 COMMENT \'The transaction input zero bytes\' CODEC(ZSTD(1)),
    `n_input_nonzero_bytes` UInt32 COMMENT \'The transaction input nonzero bytes\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, intDiv(block_number, 5000000))
ORDER BY (meta_network_name, block_number, block_hash, position)
COMMENT 'Contains execution transaction data that may not be canonical.';

CREATE TABLE IF NOT EXISTS default.imported_sources_local ON CLUSTER '{cluster}'
(
    `create_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `target_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `source` LowCardinality(String)
)
ENGINE = ReplicatedMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}')
PARTITION BY toStartOfMonth(create_date_time)
ORDER BY (create_date_time, source)
COMMENT 'Contains the list of sources that have been imported into the database';

CREATE TABLE IF NOT EXISTS default.libp2p_add_peer_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer\',
    `protocol` LowCardinality(String) COMMENT \'Protocol used by the peer\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key)
COMMENT 'Contains the details of the peers added to the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_connected_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `remote_peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the remote peer\',
    `remote_protocol` LowCardinality(String) COMMENT \'Protocol of the remote peer\',
    `remote_transport_protocol` LowCardinality(String) COMMENT \'Transport protocol of the remote peer\',
    `remote_port` Nullable(UInt16) COMMENT \'Port of the remote peer\' CODEC(ZSTD(1)),
    `remote_ip` Nullable(IPv6) COMMENT \'IP address of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_city` LowCardinality(String) COMMENT \'City of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_country` LowCardinality(String) COMMENT \'Country of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_country_code` LowCardinality(String) COMMENT \'Country code of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_agent_implementation` LowCardinality(String) COMMENT \'Implementation of the remote peer\',
    `remote_agent_version` LowCardinality(String) COMMENT \'Version of the remote peer\',
    `remote_agent_version_major` LowCardinality(String) COMMENT \'Major version of the remote peer\',
    `remote_agent_version_minor` LowCardinality(String) COMMENT \'Minor version of the remote peer\',
    `remote_agent_version_patch` LowCardinality(String) COMMENT \'Patch version of the remote peer\',
    `remote_agent_platform` LowCardinality(String) COMMENT \'Platform of the remote peer\',
    `direction` LowCardinality(String) COMMENT \'Connection direction\',
    `opened` DateTime COMMENT \'Timestamp when the connection was opened\' CODEC(DoubleDelta, ZSTD(1)),
    `transient` Bool COMMENT \'Whether the connection is transient\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, remote_peer_id_unique_key, direction, opened)
COMMENT 'Contains the details of the CONNECTED events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_deliver_message_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding of the topic\',
    `seq_number` UInt64 COMMENT \'A linearly increasing number that is unique among messages originating from the given peer\' CODEC(DoubleDelta, ZSTD(1)),
    `local_delivery` Bool COMMENT \'Indicates if the message was delivered to in-process subscribers only\',
    `peer_id_unique_key` Int64 COMMENT \'Unique key for the peer that delivered the message\',
    `message_id` String COMMENT \'Identifier of the message\' CODEC(ZSTD(1)),
    `message_size` UInt32 COMMENT \'Size of the message in bytes\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name, message_id, seq_number)
COMMENT 'Contains the details of the DELIVER_MESSAGE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_disconnected_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `remote_peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the remote peer\',
    `remote_protocol` LowCardinality(String) COMMENT \'Protocol of the remote peer\',
    `remote_transport_protocol` LowCardinality(String) COMMENT \'Transport protocol of the remote peer\',
    `remote_port` Nullable(UInt16) COMMENT \'Port of the remote peer\' CODEC(ZSTD(1)),
    `remote_ip` Nullable(IPv6) COMMENT \'IP address of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_city` LowCardinality(String) COMMENT \'City of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_country` LowCardinality(String) COMMENT \'Country of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_country_code` LowCardinality(String) COMMENT \'Country code of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the remote peer that generated the event\' CODEC(ZSTD(1)),
    `remote_agent_implementation` LowCardinality(String) COMMENT \'Implementation of the remote peer\',
    `remote_agent_version` LowCardinality(String) COMMENT \'Version of the remote peer\',
    `remote_agent_version_major` LowCardinality(String) COMMENT \'Major version of the remote peer\',
    `remote_agent_version_minor` LowCardinality(String) COMMENT \'Minor version of the remote peer\',
    `remote_agent_version_patch` LowCardinality(String) COMMENT \'Patch version of the remote peer\',
    `remote_agent_platform` LowCardinality(String) COMMENT \'Platform of the remote peer\',
    `direction` LowCardinality(String) COMMENT \'Connection direction\',
    `opened` DateTime COMMENT \'Timestamp when the connection was opened\' CODEC(DoubleDelta, ZSTD(1)),
    `transient` Bool COMMENT \'Whether the connection is transient\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, remote_peer_id_unique_key, direction, opened)
COMMENT 'Contains the details of the DISCONNECTED events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_drop_rpc_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64 COMMENT \'Unique identifier for each record\',
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer receiver\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, meta_client_name)
COMMENT 'Contains the details of the RPC messages dropped by the peer.';

CREATE TABLE IF NOT EXISTS default.libp2p_duplicate_message_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding of the topic\',
    `seq_number` UInt64 COMMENT \'A linearly increasing number that is unique among messages originating from the given peer\' CODEC(DoubleDelta, ZSTD(1)),
    `local_delivery` Bool COMMENT \'Indicates if the message was duplicated locally\',
    `peer_id_unique_key` Int64 COMMENT \'Unique key for the peer that sent the duplicate message\',
    `message_id` String COMMENT \'Identifier of the message\' CODEC(ZSTD(1)),
    `message_size` UInt32 COMMENT \'Size of the message in bytes\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name, message_id, seq_number)
COMMENT 'Contains the details of the DUPLICATE_MESSAGE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_aggregate_and_proof_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event with millisecond precision\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number associated with the event\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'Start date and time of the slot\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number associated with the event\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'Start date and time of the epoch\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot` UInt32 COMMENT \'Slot number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime COMMENT \'Start date and time of the wall clock slot when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch` UInt32 COMMENT \'Epoch number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch_start_date_time` DateTime COMMENT \'Start date and time of the wall clock epoch when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'Difference in slot start time for propagation\' CODEC(ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer\',
    `message_id` String COMMENT \'Identifier of the message\' CODEC(ZSTD(1)),
    `message_size` UInt32 COMMENT \'Size of the message in bytes\' CODEC(ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic in the gossipsub protocol\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding used for the topic\',
    `aggregator_index` UInt32 COMMENT \'Index of the validator who created this aggregate\' CODEC(DoubleDelta, ZSTD(1)),
    `committee_index` LowCardinality(String) COMMENT \'Committee index from the attestation\',
    `aggregation_bits` String COMMENT \'Bitfield of aggregated attestation\' CODEC(ZSTD(1)),
    `beacon_block_root` FixedString(66) COMMENT \'Root of the beacon block being attested to\' CODEC(ZSTD(1)),
    `source_epoch` UInt32 COMMENT \'Source epoch from the attestation\' CODEC(DoubleDelta, ZSTD(1)),
    `source_root` FixedString(66) COMMENT \'Source root from the attestation\' CODEC(ZSTD(1)),
    `target_epoch` UInt32 COMMENT \'Target epoch from the attestation\' CODEC(DoubleDelta, ZSTD(1)),
    `target_root` FixedString(66) COMMENT \'Target root from the attestation\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Name of the network associated with the client\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, peer_id_unique_key, message_id)
COMMENT 'Table for libp2p gossipsub aggregate and proof data.';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_beacon_attestation_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event with millisecond precision\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number associated with the event\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'Start date and time of the slot\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'The epoch number in the attestation\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `committee_index` LowCardinality(String) COMMENT \'The committee index in the attestation\',
    `attesting_validator_index` Nullable(UInt32) COMMENT \'The index of the validator attesting to the event\' CODEC(ZSTD(1)),
    `attesting_validator_committee_index` LowCardinality(String) COMMENT \'The committee index of the attesting validator\',
    `wallclock_slot` UInt32 COMMENT \'Slot number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime COMMENT \'Start date and time of the wall clock slot when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch` UInt32 COMMENT \'Epoch number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch_start_date_time` DateTime COMMENT \'Start date and time of the wall clock epoch when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'Difference in slot start time for propagation\' CODEC(ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer\',
    `message_id` String COMMENT \'Identifier of the message\' CODEC(ZSTD(1)),
    `message_size` UInt32 COMMENT \'Size of the message in bytes\' CODEC(ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic in the gossipsub protocol\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding used for the topic\',
    `aggregation_bits` String COMMENT \'The aggregation bits of the event in the attestation\' CODEC(ZSTD(1)),
    `beacon_block_root` FixedString(66) COMMENT \'The beacon block root hash in the attestation\' CODEC(ZSTD(1)),
    `source_epoch` UInt32 COMMENT \'The source epoch number in the attestation\' CODEC(DoubleDelta, ZSTD(1)),
    `source_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the source epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `source_root` FixedString(66) COMMENT \'The source beacon block root hash in the attestation\' CODEC(ZSTD(1)),
    `target_epoch` UInt32 COMMENT \'The target epoch number in the attestation\' CODEC(DoubleDelta, ZSTD(1)),
    `target_epoch_start_date_time` DateTime COMMENT \'The wall clock time when the target epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `target_root` FixedString(66) COMMENT \'The target beacon block root hash in the attestation\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Name of the network associated with the client\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, peer_id_unique_key, message_id)
COMMENT 'Table for libp2p gossipsub beacon attestation data.';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_beacon_block_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event with millisecond precision\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number associated with the event\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'Start date and time of the slot\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number associated with the event\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'Start date and time of the epoch\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot` UInt32 COMMENT \'Slot number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime COMMENT \'Start date and time of the wall clock slot when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch` UInt32 COMMENT \'Epoch number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch_start_date_time` DateTime COMMENT \'Start date and time of the wall clock epoch when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'Difference in slot start time for propagation\' CODEC(ZSTD(1)),
    `block` FixedString(66) COMMENT \'The beacon block root hash\' CODEC(ZSTD(1)),
    `proposer_index` UInt32 COMMENT \'The proposer index of the beacon block\' CODEC(ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer\',
    `message_id` String COMMENT \'Identifier of the message\' CODEC(ZSTD(1)),
    `message_size` UInt32 COMMENT \'Size of the message in bytes\' CODEC(ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic in the gossipsub protocol\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding used for the topic\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Name of the network associated with the client\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, peer_id_unique_key, message_id)
COMMENT 'Table for libp2p gossipsub beacon block data.';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_blob_sidecar_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event with millisecond precision\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number associated with the event\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'Start date and time of the slot\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number associated with the event\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'Start date and time of the epoch\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot` UInt32 COMMENT \'Slot number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime COMMENT \'Start date and time of the wall clock slot when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch` UInt32 COMMENT \'Epoch number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch_start_date_time` DateTime COMMENT \'Start date and time of the wall clock epoch when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'Difference in slot start time for propagation\' CODEC(ZSTD(1)),
    `proposer_index` UInt32 COMMENT \'The proposer index of the beacon block\' CODEC(ZSTD(1)),
    `blob_index` UInt32 COMMENT \'Blob index associated with the record\' CODEC(ZSTD(1)),
    `beacon_block_root` FixedString(66) CODEC(ZSTD(1)),
    `parent_root` FixedString(66) COMMENT \'Parent root of the beacon block\' CODEC(ZSTD(1)),
    `state_root` FixedString(66) COMMENT \'State root of the beacon block\' CODEC(ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer\',
    `message_id` String COMMENT \'Identifier of the message\' CODEC(ZSTD(1)),
    `message_size` UInt32 COMMENT \'Size of the message in bytes\' CODEC(ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic in the gossipsub protocol\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding used for the topic\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Name of the network associated with the client\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, peer_id_unique_key, message_id)
COMMENT 'Table for libp2p gossipsub blob sidecar data';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_data_column_sidecar_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event with millisecond precision\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number associated with the event\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'Start date and time of the slot\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number associated with the event\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'Start date and time of the epoch\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot` UInt32 COMMENT \'Slot number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime COMMENT \'Start date and time of the wall clock slot when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch` UInt32 COMMENT \'Epoch number of the wall clock when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch_start_date_time` DateTime COMMENT \'Start date and time of the wall clock epoch when the event was received\' CODEC(DoubleDelta, ZSTD(1)),
    `propagation_slot_start_diff` UInt32 COMMENT \'Difference in slot start time for propagation\' CODEC(ZSTD(1)),
    `proposer_index` UInt32 COMMENT \'The proposer index of the beacon block\' CODEC(ZSTD(1)),
    `column_index` UInt64 COMMENT \'Column index associated with the record\' CODEC(ZSTD(1)),
    `kzg_commitments_count` UInt32 COMMENT \'Number of KZG commitments associated with the record\' CODEC(ZSTD(1)),
    `beacon_block_root` FixedString(66) CODEC(ZSTD(1)),
    `parent_root` FixedString(66) COMMENT \'Parent root of the beacon block\' CODEC(ZSTD(1)),
    `state_root` FixedString(66) COMMENT \'State root of the beacon block\' CODEC(ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer\',
    `message_id` String COMMENT \'Identifier of the message\' CODEC(ZSTD(1)),
    `message_size` UInt32 COMMENT \'Size of the message in bytes\' CODEC(ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic in the gossipsub protocol\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding used for the topic\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Name of the network associated with the client\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, slot_start_date_time, meta_client_name, peer_id_unique_key, message_id)
COMMENT 'Table for libp2p gossipsub data column sidecar data';

CREATE TABLE IF NOT EXISTS default.libp2p_graft_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding of the topic\',
    `peer_id_unique_key` Int64 COMMENT \'Unique key for the peer that initiated the GRAFT (eg joined the mesh for this topic) identifies mesh membership changes per peer.\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name)
COMMENT 'Contains the details of the GRAFT events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_handle_metadata_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer involved in the RPC\',
    `error` Nullable(String) COMMENT \'Error message if the metadata handling failed\' CODEC(ZSTD(1)),
    `protocol` LowCardinality(String) COMMENT \'The protocol of the metadata handling event\',
    `direction` LowCardinality(String) COMMENT \'Direction of the RPC request (inbound or outbound)\' CODEC(ZSTD(1)),
    `attnets` String COMMENT \'Attestation subnets the peer is subscribed to\' CODEC(ZSTD(1)),
    `seq_number` UInt64 COMMENT \'Sequence number of the metadata\' CODEC(DoubleDelta, ZSTD(1)),
    `syncnets` String COMMENT \'Sync subnets the peer is subscribed to\' CODEC(ZSTD(1)),
    `custody_group_count` Nullable(UInt8) COMMENT \'Number of custody groups (0-127)\' CODEC(ZSTD(1)),
    `latency_milliseconds` Decimal(10, 3) COMMENT \'How long it took to handle the metadata request in milliseconds\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, attnets, seq_number, syncnets, latency_milliseconds)
COMMENT 'Contains the metadata handling events for libp2p peers.';

CREATE TABLE IF NOT EXISTS default.libp2p_handle_status_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer\',
    `error` Nullable(String) COMMENT \'Error message if the status handling failed\' CODEC(ZSTD(1)),
    `protocol` LowCardinality(String) COMMENT \'The protocol of the status handling event\',
    `direction` LowCardinality(String) COMMENT \'Direction of the RPC request (inbound or outbound)\' CODEC(ZSTD(1)),
    `request_finalized_epoch` Nullable(UInt32) COMMENT \'Requested finalized epoch\' CODEC(DoubleDelta, ZSTD(1)),
    `request_finalized_root` Nullable(String) COMMENT \'Requested finalized root\',
    `request_fork_digest` LowCardinality(String) COMMENT \'Requested fork digest\',
    `request_head_root` Nullable(FixedString(66)) COMMENT \'Requested head root\' CODEC(ZSTD(1)),
    `request_head_slot` Nullable(UInt32) COMMENT \'Requested head slot\' CODEC(ZSTD(1)),
    `request_earliest_available_slot` Nullable(UInt32) COMMENT \'Requested earliest available slot\' CODEC(ZSTD(1)),
    `response_finalized_epoch` Nullable(UInt32) COMMENT \'Response finalized epoch\' CODEC(DoubleDelta, ZSTD(1)),
    `response_finalized_root` Nullable(FixedString(66)) COMMENT \'Response finalized root\' CODEC(ZSTD(1)),
    `response_fork_digest` LowCardinality(String) COMMENT \'Response fork digest\',
    `response_head_root` Nullable(FixedString(66)) COMMENT \'Response head root\' CODEC(ZSTD(1)),
    `response_head_slot` Nullable(UInt32) COMMENT \'Response head slot\' CODEC(DoubleDelta, ZSTD(1)),
    `response_earliest_available_slot` Nullable(UInt32) COMMENT \'Response earliest available slot\' CODEC(ZSTD(1)),
    `latency_milliseconds` Decimal(10, 3) COMMENT \'How long it took to handle the status request in milliseconds\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, latency_milliseconds)
COMMENT 'Contains the status handling events for libp2p peers.';

CREATE TABLE IF NOT EXISTS default.libp2p_identify_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `remote_peer_id_unique_key` Int64 CODEC(ZSTD(1)),
    `success` Bool CODEC(ZSTD(1)),
    `error` Nullable(String) CODEC(ZSTD(1)),
    `remote_protocol` LowCardinality(String),
    `remote_transport_protocol` LowCardinality(String),
    `remote_port` UInt16 CODEC(ZSTD(1)),
    `remote_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `remote_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `remote_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `remote_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `remote_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `remote_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `remote_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `remote_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `remote_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `remote_agent_implementation` LowCardinality(String),
    `remote_agent_version` LowCardinality(String),
    `remote_agent_version_major` LowCardinality(String),
    `remote_agent_version_minor` LowCardinality(String),
    `remote_agent_version_patch` LowCardinality(String),
    `remote_agent_platform` LowCardinality(String),
    `protocol_version` LowCardinality(String),
    `protocols` Array(String) CODEC(ZSTD(1)),
    `listen_addrs` Array(String) CODEC(ZSTD(1)),
    `observed_addr` String CODEC(ZSTD(1)),
    `transport` LowCardinality(String),
    `security` LowCardinality(String),
    `muxer` LowCardinality(String),
    `direction` LowCardinality(String),
    `remote_multiaddr` String CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, remote_peer_id_unique_key, direction)
COMMENT 'Contains libp2p identify protocol exchange results including remote peer agent info, supported protocols, and connection metadata';

CREATE TABLE IF NOT EXISTS default.libp2p_join_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding of the topic\',
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer that joined the topic\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name)
COMMENT 'Contains the details of the JOIN events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_leave_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding of the topic\',
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer that left the topic\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name)
COMMENT 'Contains the details of the LEAVE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_peer_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64,
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `peer_id` String CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY meta_network_name
ORDER BY unique_key
COMMENT 'Lookup table mapping seahashed peer_id + network to original peer ID. Collected from deep instrumentation within forked consensus layer clients. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_prune_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding of the topic\',
    `peer_id_unique_key` Int64 COMMENT \'Unique key for the peer that was PRUNED (eg removed from the mesh for this topic) identifies mesh membership changes per peer.\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name)
COMMENT 'Contains the details of the PRUNE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_publish_message_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding of the topic\',
    `message_id` String COMMENT \'Identifier of the message\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, topic_fork_digest_value, topic_name, message_id)
COMMENT 'Contains the details of the PUBLISH_MESSAGE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_recv_rpc_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64,
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `peer_id_unique_key` Int64,
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, meta_client_name)
COMMENT 'Contains RPC messages received from peers. Collected from deep instrumentation within forked consensus layer clients. Control messages are split into separate tables referencing this via rpc_meta_unique_key. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_reject_message_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `topic_layer` LowCardinality(String) COMMENT \'Layer of the topic\',
    `topic_fork_digest_value` LowCardinality(String) COMMENT \'Fork digest value of the topic\',
    `topic_name` LowCardinality(String) COMMENT \'Name of the topic\',
    `topic_encoding` LowCardinality(String) COMMENT \'Encoding of the topic\',
    `seq_number` UInt64 COMMENT \'A linearly increasing number that is unique among messages originating from the given peer\' CODEC(DoubleDelta, ZSTD(1)),
    `local_delivery` Bool COMMENT \'Indicates if the message was rejected by local subscriber\',
    `peer_id_unique_key` Int64 COMMENT \'Unique key for the peer that rejected the message\',
    `message_id` String COMMENT \'Identifier of the message\' CODEC(ZSTD(1)),
    `message_size` UInt32 COMMENT \'Size of the message in bytes\' CODEC(ZSTD(1)),
    `reason` String COMMENT \'Reason for message rejection\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name, message_id, seq_number)
COMMENT 'Contains the details of the REJECT_MESSAGE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_remove_peer_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the event\' CODEC(DoubleDelta, ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key)
COMMENT 'Contains the details of the peers removed from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_data_column_custody_probe_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the probe was executed\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number being probed\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The wall clock time when the slot started\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number of the slot being probed\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The wall clock time when the epoch started\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_request_slot` UInt32 COMMENT \'The wallclock slot when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_request_slot_start_date_time` DateTime COMMENT \'The start time for the slot when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_request_epoch` UInt32 COMMENT \'The wallclock epoch when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_request_epoch_start_date_time` DateTime COMMENT \'The start time for the wallclock epoch when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `column_index` UInt64 COMMENT \'Column index being probed\' CODEC(ZSTD(1)),
    `column_rows_count` UInt16 COMMENT \'Number of rows in the column\' CODEC(ZSTD(1)),
    `beacon_block_root` FixedString(66) COMMENT \'Root of the beacon block\' CODEC(ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer\',
    `result` LowCardinality(String) COMMENT \'Result of the probe\' CODEC(ZSTD(1)),
    `response_time_ms` Int32 COMMENT \'Response time in milliseconds\' CODEC(ZSTD(1)),
    `error` Nullable(String) COMMENT \'Error message if probe failed\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that executed the probe\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, peer_id_unique_key, slot, column_index)
COMMENT 'Contains custody probe events for data column availability verification';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_graft_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64,
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `control_index` Int32 CODEC(DoubleDelta, ZSTD(1)),
    `rpc_meta_unique_key` Int64,
    `topic_layer` LowCardinality(String),
    `topic_fork_digest_value` LowCardinality(String),
    `topic_name` LowCardinality(String),
    `topic_encoding` LowCardinality(String),
    `peer_id_unique_key` Int64,
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, control_index, meta_client_name)
COMMENT 'Contains GRAFT control messages from gossipsub RPC. Collected from deep instrumentation within forked consensus layer clients. Peers request to join the mesh for a topic. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_idontwant_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64 COMMENT \'Unique identifier for each IDONTWANT control record\',
    `updated_date_time` DateTime COMMENT \'Timestamp when the IDONTWANT control record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the IDONTWANT control event\' CODEC(DoubleDelta, ZSTD(1)),
    `control_index` Int32 COMMENT \'Position in the RPC meta control idontwant array\' CODEC(DoubleDelta, ZSTD(1)),
    `message_index` Int32 COMMENT \'Position in the RPC meta control idontwant message_ids array\' CODEC(DoubleDelta, ZSTD(1)),
    `rpc_meta_unique_key` Int64 COMMENT \'Unique key associated with the IDONTWANT control metadata\',
    `message_id` String COMMENT \'Identifier of the message associated with the IDONTWANT control\' CODEC(ZSTD(1)),
    `peer_id_unique_key` Int64 COMMENT \'Unique key associated with the identifier of the peer involved in the IDONTWANT control\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, control_index, peer_id_unique_key, message_id, message_index, meta_client_name)
COMMENT 'Contains the details of the IDONTWANT control messages from the peer.';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_ihave_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64,
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `rpc_meta_unique_key` Int64,
    `message_index` Int32 CODEC(DoubleDelta, ZSTD(1)),
    `control_index` Int32 CODEC(DoubleDelta, ZSTD(1)),
    `topic_layer` LowCardinality(String),
    `topic_fork_digest_value` LowCardinality(String),
    `topic_name` LowCardinality(String),
    `topic_encoding` LowCardinality(String),
    `message_id` String CODEC(ZSTD(1)),
    `peer_id_unique_key` Int64,
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, control_index, message_index, meta_client_name)
COMMENT 'Contains IHAVE control messages from gossipsub. Collected from deep instrumentation within forked consensus layer clients. Peers advertise message IDs they have available. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_iwant_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64,
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `control_index` Int32 CODEC(DoubleDelta, ZSTD(1)),
    `message_index` Int32 CODEC(DoubleDelta, ZSTD(1)),
    `rpc_meta_unique_key` Int64,
    `message_id` String CODEC(ZSTD(1)),
    `peer_id_unique_key` Int64,
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, control_index, message_index, meta_client_name)
COMMENT 'Contains IWANT control messages from gossipsub. Collected from deep instrumentation within forked consensus layer clients. Peers request specific message IDs. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_prune_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64,
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `control_index` Int32 CODEC(DoubleDelta, ZSTD(1)),
    `rpc_meta_unique_key` Int64,
    `peer_id_index` Int32 CODEC(DoubleDelta, ZSTD(1)),
    `peer_id_unique_key` Int64,
    `graft_peer_id_unique_key` Nullable(Int64) COMMENT \'Unique key associated with the identifier of the graft peer involved in the Prune control\',
    `topic_layer` LowCardinality(String),
    `topic_fork_digest_value` LowCardinality(String),
    `topic_name` LowCardinality(String),
    `topic_encoding` LowCardinality(String),
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, control_index, meta_client_name)
COMMENT 'Contains PRUNE control messages from gossipsub RPC. Collected from deep instrumentation within forked consensus layer clients. Peers are removed from the mesh for a topic. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_message_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64,
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `control_index` Int32 CODEC(DoubleDelta, ZSTD(1)),
    `rpc_meta_unique_key` Int64,
    `message_id` String CODEC(ZSTD(1)),
    `topic_layer` LowCardinality(String),
    `topic_fork_digest_value` LowCardinality(String),
    `topic_name` LowCardinality(String),
    `topic_encoding` LowCardinality(String),
    `peer_id_unique_key` Int64,
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, control_index, meta_client_name)
COMMENT 'Contains RPC message metadata from gossipsub. Collected from deep instrumentation within forked consensus layer clients. Each row represents a message within an RPC with topic and message ID. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_subscription_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64,
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `control_index` Int32 CODEC(DoubleDelta, ZSTD(1)),
    `rpc_meta_unique_key` Int64,
    `subscribe` Bool,
    `topic_layer` LowCardinality(String),
    `topic_fork_digest_value` LowCardinality(String),
    `topic_name` LowCardinality(String),
    `topic_encoding` LowCardinality(String),
    `peer_id_unique_key` Int64,
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, control_index, meta_client_name)
COMMENT 'Contains RPC subscription changes from gossipsub. Collected from deep instrumentation within forked consensus layer clients. Each row represents a subscribe/unsubscribe action for a topic. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_send_rpc_local ON CLUSTER '{cluster}'
(
    `unique_key` Int64,
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `peer_id_unique_key` Int64,
    `meta_client_name` LowCardinality(String),
    `meta_client_version` LowCardinality(String),
    `meta_client_implementation` LowCardinality(String),
    `meta_client_os` LowCardinality(String),
    `meta_client_ip` Nullable(IPv6) CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, unique_key, meta_client_name)
COMMENT 'Contains RPC messages sent to peers. Collected from deep instrumentation within forked consensus layer clients. Control messages are split into separate tables referencing this via rpc_meta_unique_key. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_synthetic_heartbeat_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'Timestamp of the heartbeat event\' CODEC(DoubleDelta, ZSTD(1)),
    `remote_peer_id_unique_key` Int64 COMMENT \'Unique key of the remote peer\',
    `remote_maddrs` String COMMENT \'Multiaddress of the remote peer\' CODEC(ZSTD(1)),
    `latency_ms` Nullable(Int64) COMMENT \'EWMA latency in milliseconds (0 if unavailable)\' CODEC(ZSTD(1)),
    `direction` LowCardinality(String) COMMENT \'Connection direction (Unknown/Inbound/Outbound)\',
    `protocols` Array(String) COMMENT \'List of supported protocols\' CODEC(ZSTD(1)),
    `connection_age_ms` Nullable(Int64) COMMENT \'Connection age in milliseconds\' CODEC(ZSTD(1)),
    `remote_agent_implementation` LowCardinality(String) COMMENT \'Implementation of the remote peer\',
    `remote_agent_version` LowCardinality(String) COMMENT \'Version of the remote peer\',
    `remote_agent_version_major` LowCardinality(String) COMMENT \'Major version of the remote peer\',
    `remote_agent_version_minor` LowCardinality(String) COMMENT \'Minor version of the remote peer\',
    `remote_agent_version_patch` LowCardinality(String) COMMENT \'Patch version of the remote peer\',
    `remote_agent_platform` LowCardinality(String) COMMENT \'Platform of the remote peer\',
    `remote_ip` Nullable(IPv6) COMMENT \'IP address of the remote peer\' CODEC(ZSTD(1)),
    `remote_port` Nullable(UInt16) COMMENT \'Port of the remote peer\' CODEC(ZSTD(1)),
    `remote_geo_city` LowCardinality(String) COMMENT \'City of the remote peer\' CODEC(ZSTD(1)),
    `remote_geo_country` LowCardinality(String) COMMENT \'Country of the remote peer\' CODEC(ZSTD(1)),
    `remote_geo_country_code` LowCardinality(String) COMMENT \'Country code of the remote peer\' CODEC(ZSTD(1)),
    `remote_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the remote peer\' CODEC(ZSTD(1)),
    `remote_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the remote peer\' CODEC(ZSTD(1)),
    `remote_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the remote peer\' CODEC(ZSTD(1)),
    `remote_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'ASN of the remote peer\' CODEC(ZSTD(1)),
    `remote_geo_autonomous_system_organization` Nullable(String) COMMENT \'AS organization of the remote peer\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'ASN of the client\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'AS organization of the client\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, remote_peer_id_unique_key, updated_date_time)
COMMENT 'Contains heartbeat events from libp2p peers';

CREATE TABLE IF NOT EXISTS default.mempool_dumpster_transaction_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'When this row was last updated, this is outside the source data and used for deduplication\' CODEC(DoubleDelta, ZSTD(1)),
    `timestamp` DateTime64(3) COMMENT \'Timestamp of the transaction\' CODEC(DoubleDelta, ZSTD(1)),
    `hash` FixedString(66) COMMENT \'The hash of the transaction\' CODEC(ZSTD(1)),
    `chain_id` UInt32 COMMENT \'The chain id of the transaction\' CODEC(ZSTD(1)),
    `from` FixedString(42) COMMENT \'The address of the account that sent the transaction\' CODEC(ZSTD(1)),
    `to` Nullable(FixedString(42)) COMMENT \'The address of the account that is the transaction recipient\' CODEC(ZSTD(1)),
    `value` UInt128 COMMENT \'The value transferred with the transaction in wei\' CODEC(ZSTD(1)),
    `nonce` UInt64 COMMENT \'The nonce of the sender account at the time of the transaction\' CODEC(ZSTD(1)),
    `gas` UInt64 COMMENT \'The maximum gas provided for the transaction execution\' CODEC(ZSTD(1)),
    `gas_price` UInt128 COMMENT \'The gas price of the transaction in wei\' CODEC(ZSTD(1)),
    `gas_tip_cap` Nullable(UInt128) COMMENT \'The gas tip cap of the transaction in wei\' CODEC(ZSTD(1)),
    `gas_fee_cap` Nullable(UInt128) COMMENT \'The gas fee cap of the transaction in wei\' CODEC(ZSTD(1)),
    `data_size` UInt32 COMMENT \'The size of the call data of the transaction in bytes\' CODEC(ZSTD(1)),
    `data_4bytes` Nullable(FixedString(10)) COMMENT \'The first 4 bytes of the call data of the transaction\' CODEC(ZSTD(1)),
    `sources` Array(LowCardinality(String)) COMMENT \'The sources that saw this transaction in their mempool\',
    `included_at_block_height` Nullable(UInt64) COMMENT \'The block height at which this transaction was included\' CODEC(ZSTD(1)),
    `included_block_timestamp` Nullable(DateTime64(3)) COMMENT \'The timestamp of the block at which this transaction was included\' CODEC(DoubleDelta, ZSTD(1)),
    `inclusion_delay_ms` Nullable(Int64) COMMENT \'The delay between the transaction timestamp and the block timestamp\' CODEC(ZSTD(1))
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (chain_id, toYYYYMM(timestamp))
ORDER BY (chain_id, timestamp, hash, from, nonce, gas)
COMMENT 'Contains transactions from mempool dumpster dataset. Following the parquet schema with some additions';

CREATE TABLE IF NOT EXISTS default.mempool_transaction_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'The time when the sentry saw the transaction in the mempool\' CODEC(DoubleDelta, ZSTD(1)),
    `hash` FixedString(66) COMMENT \'The hash of the transaction\' CODEC(ZSTD(1)),
    `from` FixedString(42) COMMENT \'The address of the account that sent the transaction\' CODEC(ZSTD(1)),
    `to` Nullable(FixedString(42)) COMMENT \'The address of the account that is the transaction recipient\' CODEC(ZSTD(1)),
    `nonce` UInt64 COMMENT \'The nonce of the sender account at the time of the transaction\' CODEC(ZSTD(1)),
    `gas_price` UInt128 COMMENT \'The gas price of the transaction in wei\' CODEC(ZSTD(1)),
    `gas` UInt64 COMMENT \'The maximum gas provided for the transaction execution\' CODEC(ZSTD(1)),
    `gas_tip_cap` Nullable(UInt128) COMMENT \'The priority fee (tip) the user has set for the transaction\',
    `gas_fee_cap` Nullable(UInt128) COMMENT \'The max fee the user has set for the transaction\',
    `value` UInt128 COMMENT \'The value transferred with the transaction in wei\' CODEC(ZSTD(1)),
    `type` Nullable(UInt8) COMMENT \'The type of the transaction\',
    `size` UInt32 COMMENT \'The size of the transaction data in bytes\' CODEC(ZSTD(1)),
    `call_data_size` UInt32 COMMENT \'The size of the call data of the transaction in bytes\' CODEC(ZSTD(1)),
    `blob_gas` Nullable(UInt64) COMMENT \'The maximum gas provided for the blob transaction execution\',
    `blob_gas_fee_cap` Nullable(UInt128) COMMENT \'The max fee the user has set for the transaction\',
    `blob_hashes` Array(String) COMMENT \'The hashes of the blob commitments for blob transactions\',
    `blob_sidecars_size` Nullable(UInt32) COMMENT \'The total size of the sidecars for blob transactions in bytes\',
    `blob_sidecars_empty_size` Nullable(UInt32) COMMENT \'The total empty size of the sidecars for blob transactions in bytes\',
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `meta_execution_fork_id_hash` LowCardinality(String) COMMENT \'The hash of the fork ID of the current Ethereum network\',
    `meta_execution_fork_id_next` LowCardinality(String) COMMENT \'The fork ID of the next planned Ethereum network upgrade\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, hash, from, nonce, gas)
COMMENT 'Each row represents a transaction that was seen in the mempool by a sentry client. Sentries can report the same transaction multiple times if it has been long enough since the last report.';

CREATE TABLE IF NOT EXISTS default.mev_relay_bid_trace_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the bid was fetched\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number within the block bid\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The start time for the slot that the bid is for\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number derived from the slot that the bid is for\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The start time for the epoch that the bid is for\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_request_slot` UInt32 COMMENT \'The wallclock slot when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_request_slot_start_date_time` DateTime COMMENT \'The start time for the slot when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_request_epoch` UInt32 COMMENT \'The wallclock epoch when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_request_epoch_start_date_time` DateTime COMMENT \'The start time for the wallclock epoch when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `requested_at_slot_time` UInt32 COMMENT \'The time in the slot when the request was sent\' CODEC(ZSTD(1)),
    `response_at_slot_time` UInt32 COMMENT \'The time in the slot when the response was received\' CODEC(ZSTD(1)),
    `relay_name` String COMMENT \'The relay that the bid was fetched from\' CODEC(ZSTD(1)),
    `parent_hash` FixedString(66) COMMENT \'The parent hash of the bid\' CODEC(ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number of the bid\' CODEC(DoubleDelta, ZSTD(1)),
    `block_hash` FixedString(66) COMMENT \'The block hash of the bid\' CODEC(ZSTD(1)),
    `builder_pubkey` String COMMENT \'The builder pubkey of the bid\' CODEC(ZSTD(1)),
    `proposer_pubkey` String COMMENT \'The proposer pubkey of the bid\' CODEC(ZSTD(1)),
    `proposer_fee_recipient` FixedString(42) COMMENT \'The proposer fee recipient of the bid\' CODEC(ZSTD(1)),
    `gas_limit` UInt64 COMMENT \'The gas limit of the bid\' CODEC(DoubleDelta, ZSTD(1)),
    `gas_used` UInt64 COMMENT \'The gas used of the bid\' CODEC(DoubleDelta, ZSTD(1)),
    `value` UInt256 COMMENT \'The transaction value in float64\' CODEC(ZSTD(1)),
    `num_tx` UInt32 COMMENT \'The number of transactions in the bid\' CODEC(DoubleDelta, ZSTD(1)),
    `timestamp` Int64 COMMENT \'The timestamp of the bid\' CODEC(DoubleDelta, ZSTD(1)),
    `timestamp_ms` Int64 COMMENT \'The timestamp of the bid in milliseconds\' CODEC(DoubleDelta, ZSTD(1)),
    `optimistic_submission` Bool COMMENT \'Whether the bid was optimistic\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, relay_name, block_hash, meta_client_name, builder_pubkey, proposer_pubkey)
COMMENT 'Contains MEV relay block bids data.';

CREATE TABLE IF NOT EXISTS default.mev_relay_proposer_payload_delivered_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the payload was delivered\' CODEC(DoubleDelta, ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number within the payload\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The start time for the slot that the bid is for\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number derived from the slot that the bid is for\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The start time for the epoch that the bid is for\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot` UInt32 COMMENT \'The wallclock slot when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime COMMENT \'The start time for the slot when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch` UInt32 COMMENT \'The wallclock epoch when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch_start_date_time` DateTime COMMENT \'The start time for the wallclock epoch when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number of the payload\' CODEC(DoubleDelta, ZSTD(1)),
    `relay_name` String COMMENT \'The relay that delivered the payload\' CODEC(ZSTD(1)),
    `block_hash` FixedString(66) COMMENT \'The block hash associated with the payload\' CODEC(ZSTD(1)),
    `proposer_pubkey` String COMMENT \'The proposer pubkey that received the payload\' CODEC(ZSTD(1)),
    `builder_pubkey` String COMMENT \'The builder pubkey that sent the payload\' CODEC(ZSTD(1)),
    `proposer_fee_recipient` FixedString(42) COMMENT \'The proposer fee recipient of the payload\' CODEC(ZSTD(1)),
    `gas_limit` UInt64 COMMENT \'The gas limit of the payload\' CODEC(DoubleDelta, ZSTD(1)),
    `gas_used` UInt64 COMMENT \'The gas used by the payload\' CODEC(DoubleDelta, ZSTD(1)),
    `value` UInt256 COMMENT \'The bid value in wei\' CODEC(ZSTD(1)),
    `num_tx` UInt32 COMMENT \'The number of transactions in the payload\' CODEC(DoubleDelta, ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(slot_start_date_time))
ORDER BY (meta_network_name, slot_start_date_time, relay_name, block_hash, meta_client_name, builder_pubkey, proposer_pubkey)
COMMENT 'Contains MEV relay proposer payload delivered data.';

CREATE TABLE IF NOT EXISTS default.mev_relay_validator_registration_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the registration was fetched\' CODEC(DoubleDelta, ZSTD(1)),
    `timestamp` Int64 COMMENT \'The timestamp of the registration\' CODEC(DoubleDelta, ZSTD(1)),
    `relay_name` String COMMENT \'The relay that the registration was fetched from\' CODEC(ZSTD(1)),
    `validator_index` UInt32 COMMENT \'The validator index of the validator registration\' CODEC(ZSTD(1)),
    `gas_limit` UInt64 COMMENT \'The gas limit of the validator registration\' CODEC(DoubleDelta, ZSTD(1)),
    `fee_recipient` String COMMENT \'The fee recipient of the validator registration\' CODEC(ZSTD(1)),
    `slot` UInt32 COMMENT \'Slot number derived from the validator registration `timestamp` field\' CODEC(DoubleDelta, ZSTD(1)),
    `slot_start_date_time` DateTime COMMENT \'The slot start time derived from the validator registration `timestamp` field\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch` UInt32 COMMENT \'Epoch number derived from the validator registration `timestamp` field\' CODEC(DoubleDelta, ZSTD(1)),
    `epoch_start_date_time` DateTime COMMENT \'The epoch start time derived from the validator registration `timestamp` field\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot` UInt32 COMMENT \'The wallclock slot when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime COMMENT \'The start time for the slot when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch` UInt32 COMMENT \'The wallclock epoch when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_epoch_start_date_time` DateTime COMMENT \'The start time for the wallclock epoch when the request was sent\' CODEC(DoubleDelta, ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, meta_client_name, relay_name, validator_index, timestamp)
COMMENT 'Contains MEV relay validator registrations data.';

CREATE TABLE IF NOT EXISTS default.node_record_consensus_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the discovery module found the node\' CODEC(DoubleDelta, ZSTD(1)),
    `enr` String COMMENT \'Ethereum Node Record as text\' CODEC(ZSTD(1)),
    `node_id` String COMMENT \'ID of the Ethereum Node Record\' CODEC(ZSTD(1)),
    `peer_id_unique_key` Nullable(Int64) COMMENT \'Unique key associated with the identifier of the peer\',
    `timestamp` Int64 COMMENT \'Event timestamp in unix time\' CODEC(DoubleDelta, ZSTD(1)),
    `name` String COMMENT \'Consensus client name\' CODEC(ZSTD(1)),
    `version` LowCardinality(String) COMMENT \'Consensus client version\' CODEC(ZSTD(1)),
    `version_major` LowCardinality(String) COMMENT \'Consensus client major version\' CODEC(ZSTD(1)),
    `version_minor` LowCardinality(String) COMMENT \'Consensus client minor version\' CODEC(ZSTD(1)),
    `version_patch` LowCardinality(String) COMMENT \'Consensus client patch version\' CODEC(ZSTD(1)),
    `implementation` LowCardinality(String) COMMENT \'Consensus client implementation\' CODEC(ZSTD(1)),
    `fork_digest` String COMMENT \'Fork digest value\' CODEC(ZSTD(1)),
    `next_fork_digest` Nullable(String) COMMENT \'Next fork digest of the next scheduled fork\' CODEC(ZSTD(1)),
    `finalized_root` String COMMENT \'Finalized beacon block root\' CODEC(ZSTD(1)),
    `finalized_epoch` UInt64 COMMENT \'Finalized epoch number\' CODEC(DoubleDelta, ZSTD(1)),
    `head_root` String COMMENT \'Head beacon block root\' CODEC(ZSTD(1)),
    `head_slot` UInt64 COMMENT \'Head slot number\' CODEC(DoubleDelta, ZSTD(1)),
    `cgc` Nullable(String) COMMENT \'Represents the nodes custody group count\' CODEC(ZSTD(1)),
    `finalized_epoch_start_date_time` Nullable(DateTime) COMMENT \'Finalized epoch start time\' CODEC(DoubleDelta, ZSTD(1)),
    `head_slot_start_date_time` Nullable(DateTime) COMMENT \'Head slot start time\' CODEC(DoubleDelta, ZSTD(1)),
    `ip` Nullable(IPv6) COMMENT \'IP address of the consensus node\' CODEC(ZSTD(1)),
    `tcp` Nullable(UInt16) COMMENT \'TCP port from ENR\' CODEC(DoubleDelta, ZSTD(1)),
    `udp` Nullable(UInt16) COMMENT \'UDP port from ENR\' CODEC(DoubleDelta, ZSTD(1)),
    `quic` Nullable(UInt16) COMMENT \'QUIC port from ENR\' CODEC(DoubleDelta, ZSTD(1)),
    `has_ipv6` Bool COMMENT \'Whether the consensus node has an IPv6 address\' CODEC(ZSTD(1)),
    `geo_city` LowCardinality(String) COMMENT \'City of the consensus node\' CODEC(ZSTD(1)),
    `geo_country` LowCardinality(String) COMMENT \'Country of the consensus node\' CODEC(ZSTD(1)),
    `geo_country_code` LowCardinality(String) COMMENT \'Country code of the consensus node\' CODEC(ZSTD(1)),
    `geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the consensus node\' CODEC(ZSTD(1)),
    `geo_longitude` Nullable(Float64) COMMENT \'Longitude of the consensus node\' CODEC(ZSTD(1)),
    `geo_latitude` Nullable(Float64) COMMENT \'Latitude of the consensus node\' CODEC(ZSTD(1)),
    `geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the consensus node\' CODEC(ZSTD(1)),
    `geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the consensus node\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, enr, meta_client_name)
COMMENT 'Contains consensus node records discovered by the Xatu discovery module.';

CREATE TABLE IF NOT EXISTS default.node_record_execution_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime COMMENT \'Timestamp when the record was last updated\' CODEC(DoubleDelta, ZSTD(1)),
    `event_date_time` DateTime64(3) COMMENT \'When the event was generated\' CODEC(DoubleDelta, ZSTD(1)),
    `enr` String COMMENT \'Ethereum Node Record as text\' CODEC(ZSTD(1)),
    `name` String COMMENT \'Execution client name\' CODEC(ZSTD(1)),
    `version` LowCardinality(String) COMMENT \'Execution client version\' CODEC(ZSTD(1)),
    `version_major` LowCardinality(String) COMMENT \'Execution client major version\' CODEC(ZSTD(1)),
    `version_minor` LowCardinality(String) COMMENT \'Execution client minor version\' CODEC(ZSTD(1)),
    `version_patch` LowCardinality(String) COMMENT \'Execution client patch version\' CODEC(ZSTD(1)),
    `implementation` LowCardinality(String) COMMENT \'Execution client implementation\' CODEC(ZSTD(1)),
    `capabilities` Array(String) COMMENT \'List of capabilities (e.g., eth/65,eth/66)\' CODEC(ZSTD(1)),
    `protocol_version` String COMMENT \'Protocol version\' CODEC(ZSTD(1)),
    `total_difficulty` String COMMENT \'Total difficulty of the chain\' CODEC(ZSTD(1)),
    `head` String COMMENT \'Head block hash\' CODEC(ZSTD(1)),
    `genesis` String COMMENT \'Genesis block hash\' CODEC(ZSTD(1)),
    `fork_id_hash` String COMMENT \'Fork ID hash\' CODEC(ZSTD(1)),
    `fork_id_next` String COMMENT \'Fork ID next block\' CODEC(ZSTD(1)),
    `node_id` String COMMENT \'Node ID from ENR\' CODEC(ZSTD(1)),
    `ip` Nullable(IPv6) COMMENT \'IP address of the execution node\' CODEC(ZSTD(1)),
    `tcp` Nullable(UInt16) COMMENT \'TCP port from ENR\' CODEC(DoubleDelta, ZSTD(1)),
    `udp` Nullable(UInt16) COMMENT \'UDP port from ENR\' CODEC(DoubleDelta, ZSTD(1)),
    `has_ipv6` Bool COMMENT \'Whether the execution node has an IPv6 address\' CODEC(ZSTD(1)),
    `geo_city` LowCardinality(String) COMMENT \'City of the execution node\' CODEC(ZSTD(1)),
    `geo_country` LowCardinality(String) COMMENT \'Country of the execution node\' CODEC(ZSTD(1)),
    `geo_country_code` LowCardinality(String) COMMENT \'Country code of the execution node\' CODEC(ZSTD(1)),
    `geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the execution node\' CODEC(ZSTD(1)),
    `geo_longitude` Nullable(Float64) COMMENT \'Longitude of the execution node\' CODEC(ZSTD(1)),
    `geo_latitude` Nullable(Float64) COMMENT \'Latitude of the execution node\' CODEC(ZSTD(1)),
    `geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the execution node\' CODEC(ZSTD(1)),
    `geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the execution node\' CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String) COMMENT \'Name of the client that generated the event\',
    `meta_client_version` LowCardinality(String) COMMENT \'Version of the client that generated the event\',
    `meta_client_implementation` LowCardinality(String) COMMENT \'Implementation of the client that generated the event\',
    `meta_client_os` LowCardinality(String) COMMENT \'Operating system of the client that generated the event\',
    `meta_client_ip` Nullable(IPv6) COMMENT \'IP address of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_city` LowCardinality(String) COMMENT \'City of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country` LowCardinality(String) COMMENT \'Country of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_country_code` LowCardinality(String) COMMENT \'Country code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_continent_code` LowCardinality(String) COMMENT \'Continent code of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_longitude` Nullable(Float64) COMMENT \'Longitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_latitude` Nullable(Float64) COMMENT \'Latitude of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_number` Nullable(UInt32) COMMENT \'Autonomous system number of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_client_geo_autonomous_system_organization` Nullable(String) COMMENT \'Autonomous system organization of the client that generated the event\' CODEC(ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_date_time))
ORDER BY (meta_network_name, event_date_time, node_id, meta_client_name)
COMMENT 'Contains execution node records discovered by the Xatu discovery module.';

-- observoor database

CREATE TABLE IF NOT EXISTS observoor.block_merge_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `device_id` UInt32 CODEC(ZSTD(1)),
    `rw` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type, device_id, rw)
COMMENT 'Aggregated block device I/O merge metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.cpu_utilization_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `total_on_cpu_ns` Float32 CODEC(ZSTD(1)),
    `event_count` UInt32 CODEC(ZSTD(1)),
    `active_cores` UInt16 CODEC(ZSTD(1)),
    `system_cores` UInt16 CODEC(ZSTD(1)),
    `max_core_on_cpu_ns` Float32 CODEC(ZSTD(1)),
    `max_core_id` UInt32 CODEC(ZSTD(1)),
    `mean_core_pct` Float32 CODEC(ZSTD(1)),
    `min_core_pct` Float32 CODEC(ZSTD(1)),
    `max_core_pct` Float32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated CPU utilization metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.disk_bytes_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `device_id` UInt32 CODEC(ZSTD(1)),
    `rw` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type, device_id, rw)
COMMENT 'Aggregated disk I/O byte metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.disk_latency_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `device_id` UInt32 CODEC(ZSTD(1)),
    `rw` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type, device_id, rw)
COMMENT 'Aggregated disk I/O latency metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.disk_queue_depth_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `device_id` UInt32 CODEC(ZSTD(1)),
    `rw` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type, device_id, rw)
COMMENT 'Aggregated disk queue depth metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.fd_close_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated file descriptor close metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.fd_open_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated file descriptor open metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.host_specs_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `event_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `host_id` String,
    `kernel_release` LowCardinality(String),
    `os_name` LowCardinality(String),
    `architecture` LowCardinality(String),
    `cpu_model` String,
    `cpu_vendor` LowCardinality(String),
    `cpu_online_cores` UInt16 CODEC(ZSTD(1)),
    `cpu_logical_cores` UInt16 CODEC(ZSTD(1)),
    `cpu_physical_cores` UInt16 CODEC(ZSTD(1)),
    `cpu_performance_cores` UInt16 CODEC(ZSTD(1)),
    `cpu_efficiency_cores` UInt16 CODEC(ZSTD(1)),
    `cpu_unknown_type_cores` UInt16 CODEC(ZSTD(1)),
    `cpu_logical_ids` Array(UInt16),
    `cpu_core_ids` Array(Int32),
    `cpu_package_ids` Array(Int32),
    `cpu_die_ids` Array(Int32),
    `cpu_cluster_ids` Array(Int32),
    `cpu_core_types` Array(UInt8),
    `cpu_core_type_labels` Array(String),
    `cpu_online_flags` Array(UInt8),
    `cpu_max_freq_khz` Array(UInt64),
    `cpu_base_freq_khz` Array(UInt64),
    `memory_total_bytes` UInt64 CODEC(ZSTD(1)),
    `memory_type` LowCardinality(String),
    `memory_speed_mts` UInt32 CODEC(ZSTD(1)),
    `memory_dimm_count` UInt16 CODEC(ZSTD(1)),
    `memory_dimm_sizes_bytes` Array(UInt64),
    `memory_dimm_types` Array(String),
    `memory_dimm_speeds_mts` Array(UInt32),
    `memory_dimm_configured_speeds_mts` Array(UInt32),
    `memory_dimm_locators` Array(String),
    `memory_dimm_bank_locators` Array(String),
    `memory_dimm_manufacturers` Array(String),
    `memory_dimm_part_numbers` Array(String),
    `memory_dimm_serials` Array(String),
    `disk_count` UInt16 CODEC(ZSTD(1)),
    `disk_total_bytes` UInt64 CODEC(ZSTD(1)),
    `disk_names` Array(String),
    `disk_models` Array(String),
    `disk_vendors` Array(String),
    `disk_serials` Array(String),
    `disk_sizes_bytes` Array(UInt64),
    `disk_rotational` Array(UInt8),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_time))
ORDER BY (meta_network_name, event_time, host_id, meta_client_name)
COMMENT 'Periodic host hardware specification snapshots including CPU, memory, and disk details';

CREATE TABLE IF NOT EXISTS observoor.mem_compaction_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated memory compaction metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.mem_reclaim_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated memory reclaim metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.memory_usage_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `vm_size_bytes` UInt64 CODEC(ZSTD(1)),
    `vm_rss_bytes` UInt64 CODEC(ZSTD(1)),
    `rss_anon_bytes` UInt64 CODEC(ZSTD(1)),
    `rss_file_bytes` UInt64 CODEC(ZSTD(1)),
    `rss_shmem_bytes` UInt64 CODEC(ZSTD(1)),
    `vm_swap_bytes` UInt64 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Periodic memory usage snapshots of Ethereum client processes from /proc/[pid]/status';

CREATE TABLE IF NOT EXISTS observoor.net_io_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `port_label` LowCardinality(String),
    `direction` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type, port_label, direction)
COMMENT 'Aggregated network I/O metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.oom_kill_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated OOM kill events from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.page_fault_major_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated major page fault metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.page_fault_minor_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated minor page fault metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.process_exit_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated process exit events from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.process_fd_usage_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `open_fds` UInt32 CODEC(ZSTD(1)),
    `fd_limit_soft` UInt64 CODEC(ZSTD(1)),
    `fd_limit_hard` UInt64 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Periodic file descriptor usage snapshots of Ethereum client processes from /proc/[pid]/fd and /proc/[pid]/limits';

CREATE TABLE IF NOT EXISTS observoor.process_io_usage_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `rchar_bytes` UInt64 CODEC(ZSTD(1)),
    `wchar_bytes` UInt64 CODEC(ZSTD(1)),
    `syscr` UInt64 CODEC(ZSTD(1)),
    `syscw` UInt64 CODEC(ZSTD(1)),
    `read_bytes` UInt64 CODEC(ZSTD(1)),
    `write_bytes` UInt64 CODEC(ZSTD(1)),
    `cancelled_write_bytes` Int64 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Periodic I/O usage snapshots of Ethereum client processes from /proc/[pid]/io';

CREATE TABLE IF NOT EXISTS observoor.process_sched_usage_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `threads` UInt32 CODEC(ZSTD(1)),
    `voluntary_ctxt_switches` UInt64 CODEC(ZSTD(1)),
    `nonvoluntary_ctxt_switches` UInt64 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Periodic scheduler usage snapshots of Ethereum client processes from /proc/[pid]/status and /proc/[pid]/sched';

CREATE TABLE IF NOT EXISTS observoor.raw_events_local ON CLUSTER '{cluster}'
(
    `timestamp_ns` UInt64 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot` UInt64 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `cl_syncing` Bool CODEC(ZSTD(1)),
    `el_optimistic` Bool CODEC(ZSTD(1)),
    `el_offline` Bool CODEC(ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `tid` UInt32 CODEC(ZSTD(1)),
    `event_type` LowCardinality(String),
    `client_type` LowCardinality(String),
    `latency_ns` UInt64 CODEC(ZSTD(1)),
    `bytes` Int64 CODEC(ZSTD(1)),
    `src_port` UInt16 CODEC(ZSTD(1)),
    `dst_port` UInt16 CODEC(ZSTD(1)),
    `fd` Int32 CODEC(ZSTD(1)),
    `filename` String CODEC(ZSTD(1)),
    `voluntary` Bool CODEC(ZSTD(1)),
    `on_cpu_ns` UInt64 CODEC(ZSTD(1)),
    `runqueue_ns` UInt64 CODEC(ZSTD(1)),
    `off_cpu_ns` UInt64 CODEC(ZSTD(1)),
    `major` Bool CODEC(ZSTD(1)),
    `address` UInt64 CODEC(ZSTD(1)),
    `pages` UInt64 CODEC(ZSTD(1)),
    `rw` UInt8 CODEC(ZSTD(1)),
    `queue_depth` UInt32 CODEC(ZSTD(1)),
    `device_id` UInt32 CODEC(ZSTD(1)),
    `tcp_state` UInt8 CODEC(ZSTD(1)),
    `tcp_old_state` UInt8 CODEC(ZSTD(1)),
    `tcp_srtt_us` UInt32 CODEC(ZSTD(1)),
    `tcp_cwnd` UInt32 CODEC(ZSTD(1)),
    `exit_code` UInt32 CODEC(ZSTD(1)),
    `target_pid` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}')
PARTITION BY (meta_network_name, toYYYYMM(wallclock_slot_start_date_time))
ORDER BY (meta_network_name, wallclock_slot_start_date_time, client_type, event_type, pid)
COMMENT 'Raw eBPF events captured from Ethereum client processes, one row per kernel event';

CREATE TABLE IF NOT EXISTS observoor.sched_off_cpu_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated scheduler off-CPU metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.sched_on_cpu_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated scheduler on-CPU metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.sched_runqueue_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated scheduler run queue metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.swap_in_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated swap-in metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.swap_out_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated swap-out metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.sync_state_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `event_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `cl_syncing` Bool CODEC(ZSTD(1)),
    `el_optimistic` Bool CODEC(ZSTD(1)),
    `el_offline` Bool CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(event_time))
ORDER BY (meta_network_name, event_time, meta_client_name)
COMMENT 'Sync state snapshots for consensus and execution layers';

CREATE TABLE IF NOT EXISTS observoor.syscall_epoll_wait_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated epoll_wait syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_fdatasync_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated fdatasync syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_fsync_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated fsync syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_futex_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated futex syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_mmap_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated mmap syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_pwrite_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated pwrite syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_read_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated read syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_write_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `histogram` Tuple(,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated write syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.tcp_cwnd_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `port_label` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type, port_label)
COMMENT 'Aggregated TCP congestion window metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.tcp_retransmit_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `port_label` LowCardinality(String),
    `direction` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type, port_label, direction)
COMMENT 'Aggregated TCP retransmit metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.tcp_rtt_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `port_label` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `min` Float32 CODEC(ZSTD(1)),
    `max` Float32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type, port_label)
COMMENT 'Aggregated TCP round-trip time metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.tcp_state_change_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `window_start` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `interval_ms` UInt16 CODEC(ZSTD(1)),
    `wallclock_slot` UInt32 CODEC(DoubleDelta, ZSTD(1)),
    `wallclock_slot_start_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `pid` UInt32 CODEC(ZSTD(1)),
    `client_type` LowCardinality(String),
    `sum` Float32 CODEC(ZSTD(1)),
    `count` UInt32 CODEC(ZSTD(1)),
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String)
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY (meta_network_name, toYYYYMM(window_start))
ORDER BY (meta_network_name, window_start, meta_client_name, pid, client_type)
COMMENT 'Aggregated TCP state change events from eBPF tracing of Ethereum client processes';

-- admin database

CREATE TABLE IF NOT EXISTS admin.cryo_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime CODEC(DoubleDelta, ZSTD(1)),
    `dataset` LowCardinality(String),
    `mode` LowCardinality(String),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\'
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY meta_network_name
ORDER BY (dataset, mode, meta_network_name)
COMMENT 'Tracks cryo dataset processing state per block';

CREATE TABLE IF NOT EXISTS admin.execution_block_local ON CLUSTER '{cluster}'
(
    `updated_date_time` DateTime64(3) CODEC(DoubleDelta, ZSTD(1)),
    `block_number` UInt64 COMMENT \'The block number\' CODEC(DoubleDelta, ZSTD(1)),
    `processor` LowCardinality(String) COMMENT \'The type of processor that processed the block\',
    `meta_network_name` LowCardinality(String) COMMENT \'Ethereum network name\',
    `complete` UInt8,
    `task_count` UInt32
)
ENGINE = ReplicatedReplacingMergeTree('/clickhouse/{installation}/{cluster}/tables/{shard}/{database}/{table}', '{replica}', updated_date_time)
PARTITION BY meta_network_name
ORDER BY (block_number, processor, meta_network_name)
COMMENT 'Tracks execution block processing state';

-- DISTRIBUTED TABLES
-- default database

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_beacon_blob ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_beacon_blob_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_beacon_blob_local', cityHash64(slot_start_date_time, meta_client_name, block_root))
COMMENT 'Contains beacon API blob metadata derived from block blob_kzg_commitments from each sentry client attached to a beacon node';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_beacon_committee ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_beacon_committee_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_beacon_committee_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, committee_index))
COMMENT 'Contains beacon API /eth/v1/beacon/states/{state_id}/committees data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_attestation ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_attestation_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_attestation_local', cityHash64(slot_start_date_time, meta_client_name))
COMMENT 'Contains beacon API eventstream "attestation" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_blob_sidecar ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_blob_sidecar_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_blob_sidecar_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, block_root, blob_index))
COMMENT 'Contains beacon API eventstream "blob_sidecar" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_block ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_block_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_block_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, block))
COMMENT 'Contains beacon API eventstream "block" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_block_gossip ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_block_gossip_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_block_gossip_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, block))
COMMENT 'Contains beacon API eventstream "block_gossip" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_chain_reorg ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_chain_reorg_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_chain_reorg_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, old_head_block, new_head_block))
COMMENT 'Contains beacon API eventstream "chain reorg" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_contribution_and_proof ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_contribution_and_proof_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_contribution_and_proof_local', cityHash64(contribution_slot_start_date_time, meta_network_name, meta_client_name, contribution_beacon_block_root, contribution_subcommittee_index, signature))
COMMENT 'Contains beacon API eventstream "contribution and proof" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_data_column_sidecar ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_data_column_sidecar_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_data_column_sidecar_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, block_root, column_index))
COMMENT 'Contains beacon API eventstream "data_column_sidecar" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_finalized_checkpoint ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_finalized_checkpoint_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_finalized_checkpoint_local', cityHash64(epoch_start_date_time, meta_network_name, meta_client_name, block, state))
COMMENT 'Contains beacon API eventstream "finalized checkpoint" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_head ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_head_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_head_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, block, previous_duty_dependent_root, current_duty_dependent_root))
COMMENT 'Xatu Sentry subscribes to a beacon node\'s Beacon API event-stream and captures head events. Each row represents a `head` event from the Beacon API `/eth/v1/events?topics=head`, indicating the chain\'s canonical head has been updated. Sentry adds client metadata and propagation timing. Partition: monthly by `slot_start_date_time`.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_events_voluntary_exit ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_events_voluntary_exit_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_events_voluntary_exit_local', cityHash64(wallclock_epoch_start_date_time, meta_network_name, meta_client_name, validator_index))
COMMENT 'Contains beacon API eventstream "voluntary exit" data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_proposer_duty ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_proposer_duty_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_proposer_duty_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, proposer_validator_index))
COMMENT 'Contains a proposer duty from a beacon block.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v1_validator_attestation_data ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v1_validator_attestation_data_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v1_validator_attestation_data_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, committee_index, beacon_block_root, source_root, target_root))
COMMENT 'Contains beacon API validator attestation data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v2_beacon_block ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v2_beacon_block_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v2_beacon_block_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, block_root, parent_root, state_root))
COMMENT 'Contains beacon API /eth/v2/beacon/blocks/{block_id} data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_eth_v3_validator_block ON CLUSTER '{cluster}'
AS default.beacon_api_eth_v3_validator_block_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_eth_v3_validator_block_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, event_date_time))
COMMENT 'Contains beacon API /eth/v3/validator/blocks/{slot} data from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_api_slot ON CLUSTER '{cluster}'
AS default.beacon_api_slot_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_api_slot_local', cityHash64(slot_start_date_time, slot))
COMMENT 'Aggregated beacon API slot data. Each row represents a slot from each sentry client attached to a beacon node.';

CREATE TABLE IF NOT EXISTS default.beacon_block_classification ON CLUSTER '{cluster}'
AS default.beacon_block_classification_local
ENGINE = Distributed('{cluster}', 'default', 'beacon_block_classification_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, proposer_index))
COMMENT 'Contains beacon block classification for a given slot. This is a best guess based on the client probabilities of the proposer. This is not guaranteed to be correct.';

CREATE TABLE IF NOT EXISTS default.blob_submitter ON CLUSTER '{cluster}'
AS default.blob_submitter_local
ENGINE = Distributed('{cluster}', 'default', 'blob_submitter_local', cityHash64(address, meta_network_name))
COMMENT 'Contains blob submitter address to name mappings.';

CREATE TABLE IF NOT EXISTS default.block_native_mempool_transaction ON CLUSTER '{cluster}'
AS default.block_native_mempool_transaction_local
ENGINE = Distributed('{cluster}', 'default', 'block_native_mempool_transaction_local', cityHash64(detecttime, network, hash, fromaddress, nonce, gas))
COMMENT 'Contains transactions from block native mempool dataset';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_blob_sidecar ON CLUSTER '{cluster}'
AS default.canonical_beacon_blob_sidecar_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_blob_sidecar_local', cityHash64(slot_start_date_time, meta_network_name, block_root, blob_index))
COMMENT 'Contains a blob sidecar from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block ON CLUSTER '{cluster}'
AS default.canonical_beacon_block_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_block_local', cityHash64(slot_start_date_time, meta_network_name))
COMMENT 'Contains beacon block from a beacon node.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_attester_slashing ON CLUSTER '{cluster}'
AS default.canonical_beacon_block_attester_slashing_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_block_attester_slashing_local', cityHash64(slot_start_date_time, meta_network_name, block_root, attestation_1_attesting_indices, attestation_2_attesting_indices, attestation_1_data_slot, attestation_2_data_slot, attestation_1_data_beacon_block_root, attestation_2_data_beacon_block_root))
COMMENT 'Contains attester slashing from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_bls_to_execution_change ON CLUSTER '{cluster}'
AS default.canonical_beacon_block_bls_to_execution_change_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_block_bls_to_execution_change_local', cityHash64(slot_start_date_time, meta_network_name, block_root, exchanging_message_validator_index, exchanging_message_from_bls_pubkey, exchanging_message_to_execution_address))
COMMENT 'Contains bls to execution change from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_deposit ON CLUSTER '{cluster}'
AS default.canonical_beacon_block_deposit_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_block_deposit_local', cityHash64(slot_start_date_time, meta_network_name, block_root, deposit_data_pubkey, deposit_proof))
COMMENT 'Contains a deposit from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_execution_transaction ON CLUSTER '{cluster}'
AS default.canonical_beacon_block_execution_transaction_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_block_execution_transaction_local', cityHash64(slot_start_date_time, meta_network_name, block_root, position, hash, nonce))
COMMENT 'Contains execution transaction from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_proposer_slashing ON CLUSTER '{cluster}'
AS default.canonical_beacon_block_proposer_slashing_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_block_proposer_slashing_local', cityHash64(slot_start_date_time, meta_network_name, block_root, signed_header_1_message_slot, signed_header_2_message_slot, signed_header_1_message_proposer_index, signed_header_2_message_proposer_index, signed_header_1_message_body_root, signed_header_2_message_body_root))
COMMENT 'Contains proposer slashing from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_sync_aggregate ON CLUSTER '{cluster}'
AS default.canonical_beacon_block_sync_aggregate_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_block_sync_aggregate_local', cityHash64(slot_start_date_time, meta_network_name, slot))
COMMENT 'Contains canonical beacon block sync aggregate data with expanded validator participation.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_voluntary_exit ON CLUSTER '{cluster}'
AS default.canonical_beacon_block_voluntary_exit_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_block_voluntary_exit_local', cityHash64(slot_start_date_time, meta_network_name, block_root, voluntary_exit_message_epoch, voluntary_exit_message_validator_index))
COMMENT 'Contains a voluntary exit from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_block_withdrawal ON CLUSTER '{cluster}'
AS default.canonical_beacon_block_withdrawal_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_block_withdrawal_local', cityHash64(slot_start_date_time, meta_network_name, block_root, withdrawal_index, withdrawal_validator_index))
COMMENT 'Contains a withdrawal from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_committee ON CLUSTER '{cluster}'
AS default.canonical_beacon_committee_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_committee_local', cityHash64(slot_start_date_time, meta_network_name, committee_index))
COMMENT 'Contains canonical beacon API /eth/v1/beacon/committees data.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_elaborated_attestation ON CLUSTER '{cluster}'
AS default.canonical_beacon_elaborated_attestation_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_elaborated_attestation_local', cityHash64(slot_start_date_time, meta_network_name, block_root, block_slot, position_in_block, beacon_block_root, slot, committee_index, source_root, target_root))
COMMENT 'Contains elaborated attestations from beacon blocks.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_proposer_duty ON CLUSTER '{cluster}'
AS default.canonical_beacon_proposer_duty_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_proposer_duty_local', cityHash64(slot_start_date_time, meta_network_name, proposer_validator_index, proposer_pubkey))
COMMENT 'Contains a proposer duty from a beacon block.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_sync_committee ON CLUSTER '{cluster}'
AS default.canonical_beacon_sync_committee_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_sync_committee_local', cityHash64(epoch_start_date_time, meta_network_name, sync_committee_period))
COMMENT 'Contains canonical beacon API /eth/v1/beacon/states/{state_id}/sync_committees data.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_validators ON CLUSTER '{cluster}'
AS default.canonical_beacon_validators_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_validators_local', cityHash64(epoch_start_date_time, meta_network_name, index, status))
COMMENT 'Contains a validator state for an epoch.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_validators_pubkeys ON CLUSTER '{cluster}'
AS default.canonical_beacon_validators_pubkeys_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_validators_pubkeys_local', cityHash64(index, meta_network_name))
COMMENT 'Contains a validator pubkeys for an epoch.';

CREATE TABLE IF NOT EXISTS default.canonical_beacon_validators_withdrawal_credentials ON CLUSTER '{cluster}'
AS default.canonical_beacon_validators_withdrawal_credentials_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_beacon_validators_withdrawal_credentials_local', cityHash64(index, meta_network_name))
COMMENT 'Contains a validator withdrawal credentials for an epoch.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_address_appearances ON CLUSTER '{cluster}'
AS default.canonical_execution_address_appearances_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_address_appearances_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution address appearance data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_balance_diffs ON CLUSTER '{cluster}'
AS default.canonical_execution_balance_diffs_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_balance_diffs_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution balance diff data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_balance_reads ON CLUSTER '{cluster}'
AS default.canonical_execution_balance_reads_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_balance_reads_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution balance read data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_block ON CLUSTER '{cluster}'
AS default.canonical_execution_block_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_block_local', cityHash64(block_number, meta_network_name))
COMMENT 'Contains canonical execution block data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_contracts ON CLUSTER '{cluster}'
AS default.canonical_execution_contracts_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_contracts_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution contract data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_erc20_transfers ON CLUSTER '{cluster}'
AS default.canonical_execution_erc20_transfers_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_erc20_transfers_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution erc20 transfer data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_erc721_transfers ON CLUSTER '{cluster}'
AS default.canonical_execution_erc721_transfers_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_erc721_transfers_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution erc721 transfer data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_four_byte_counts ON CLUSTER '{cluster}'
AS default.canonical_execution_four_byte_counts_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_four_byte_counts_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution four byte count data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_logs ON CLUSTER '{cluster}'
AS default.canonical_execution_logs_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_logs_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution logs data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_native_transfers ON CLUSTER '{cluster}'
AS default.canonical_execution_native_transfers_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_native_transfers_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution native transfer data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_nonce_diffs ON CLUSTER '{cluster}'
AS default.canonical_execution_nonce_diffs_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_nonce_diffs_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution nonce diff data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_nonce_reads ON CLUSTER '{cluster}'
AS default.canonical_execution_nonce_reads_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_nonce_reads_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution nonce read data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_storage_diffs ON CLUSTER '{cluster}'
AS default.canonical_execution_storage_diffs_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_storage_diffs_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution storage diffs data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_storage_reads ON CLUSTER '{cluster}'
AS default.canonical_execution_storage_reads_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_storage_reads_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution storage reads data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_traces ON CLUSTER '{cluster}'
AS default.canonical_execution_traces_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_traces_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution traces data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_transaction ON CLUSTER '{cluster}'
AS default.canonical_execution_transaction_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_transaction_local', cityHash64(block_number, meta_network_name, transaction_hash))
COMMENT 'Contains canonical execution transaction data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_transaction_structlog ON CLUSTER '{cluster}'
AS default.canonical_execution_transaction_structlog_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_transaction_structlog_local', cityHash64(block_number, meta_network_name, transaction_hash, index))
COMMENT 'Contains canonical execution transaction structlog data.';

CREATE TABLE IF NOT EXISTS default.canonical_execution_transaction_structlog_agg ON CLUSTER '{cluster}'
AS default.canonical_execution_transaction_structlog_agg_local
ENGINE = Distributed('{cluster}', 'default', 'canonical_execution_transaction_structlog_agg_local', cityHash64(block_number, meta_network_name, transaction_hash, call_frame_id))
COMMENT 'Aggregated EVM execution data. Summary rows (operation="") contain frame metadata. Per-opcode rows contain aggregated gas/count per (frame, opcode).';

CREATE TABLE IF NOT EXISTS default.consensus_engine_api_get_blobs ON CLUSTER '{cluster}'
AS default.consensus_engine_api_get_blobs_local
ENGINE = Distributed('{cluster}', 'default', 'consensus_engine_api_get_blobs_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, block_root, event_date_time))
COMMENT 'Contains timing and instrumentation data for engine_getBlobs calls between the consensus and execution layer.';

CREATE TABLE IF NOT EXISTS default.consensus_engine_api_new_payload ON CLUSTER '{cluster}'
AS default.consensus_engine_api_new_payload_local
ENGINE = Distributed('{cluster}', 'default', 'consensus_engine_api_new_payload_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, block_hash, event_date_time))
COMMENT 'Contains timing and instrumentation data for engine_newPayload calls between the consensus and execution layer.';

CREATE TABLE IF NOT EXISTS default.ethseer_validator_entity ON CLUSTER '{cluster}'
AS default.ethseer_validator_entity_local
ENGINE = Distributed('{cluster}', 'default', 'ethseer_validator_entity_local', cityHash64(index, pubkey, meta_network_name))
COMMENT 'Contains a mapping of validators to entities';

CREATE TABLE IF NOT EXISTS default.execution_block_metrics ON CLUSTER '{cluster}'
AS default.execution_block_metrics_local
ENGINE = Distributed('{cluster}', 'default', 'execution_block_metrics_local', cityHash64(block_number, meta_network_name, meta_client_name))
COMMENT 'Contains detailed performance metrics from execution client structured logging for block execution';

CREATE TABLE IF NOT EXISTS default.execution_engine_get_blobs ON CLUSTER '{cluster}'
AS default.execution_engine_get_blobs_local
ENGINE = Distributed('{cluster}', 'default', 'execution_engine_get_blobs_local', cityHash64(event_date_time, meta_network_name, meta_client_name))
COMMENT 'Contains timing and instrumentation data for engine_getBlobs calls from the execution layer perspective.';

CREATE TABLE IF NOT EXISTS default.execution_engine_new_payload ON CLUSTER '{cluster}'
AS default.execution_engine_new_payload_local
ENGINE = Distributed('{cluster}', 'default', 'execution_engine_new_payload_local', cityHash64(block_number, meta_network_name, meta_client_name, block_hash, event_date_time))
COMMENT 'Contains timing and instrumentation data for engine_newPayload calls from the execution layer perspective.';

CREATE TABLE IF NOT EXISTS default.execution_state_size ON CLUSTER '{cluster}'
AS default.execution_state_size_local
ENGINE = Distributed('{cluster}', 'default', 'execution_state_size_local', cityHash64(block_number, meta_network_name, meta_client_name, state_root, event_date_time))
COMMENT 'Contains execution layer state size metrics including account, contract code, and storage data measurements at specific block heights.';

CREATE TABLE IF NOT EXISTS default.execution_transaction ON CLUSTER '{cluster}'
AS default.execution_transaction_local
ENGINE = Distributed('{cluster}', 'default', 'execution_transaction_local', cityHash64(block_number, meta_network_name, block_hash, position))
COMMENT 'Contains execution transaction data that may not be canonical.';

CREATE TABLE IF NOT EXISTS default.imported_sources ON CLUSTER '{cluster}'
AS default.imported_sources_local
ENGINE = Distributed('{cluster}', 'default', 'imported_sources_local', rand())
COMMENT 'Contains the list of sources that have been imported into the database';

CREATE TABLE IF NOT EXISTS default.libp2p_add_peer ON CLUSTER '{cluster}'
AS default.libp2p_add_peer_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_add_peer_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key))
COMMENT 'Contains the details of the peers added to the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_connected ON CLUSTER '{cluster}'
AS default.libp2p_connected_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_connected_local', cityHash64(event_date_time, meta_network_name, meta_client_name, remote_peer_id_unique_key, direction, opened))
COMMENT 'Contains the details of the CONNECTED events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_deliver_message ON CLUSTER '{cluster}'
AS default.libp2p_deliver_message_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_deliver_message_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name, message_id, seq_number))
COMMENT 'Contains the details of the DELIVER_MESSAGE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_disconnected ON CLUSTER '{cluster}'
AS default.libp2p_disconnected_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_disconnected_local', cityHash64(event_date_time, meta_network_name, meta_client_name, remote_peer_id_unique_key, direction, opened))
COMMENT 'Contains the details of the DISCONNECTED events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_drop_rpc ON CLUSTER '{cluster}'
AS default.libp2p_drop_rpc_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_drop_rpc_local', unique_key)
COMMENT 'Contains the details of the RPC messages dropped by the peer.';

CREATE TABLE IF NOT EXISTS default.libp2p_duplicate_message ON CLUSTER '{cluster}'
AS default.libp2p_duplicate_message_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_duplicate_message_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name, message_id, seq_number))
COMMENT 'Contains the details of the DUPLICATE_MESSAGE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_aggregate_and_proof ON CLUSTER '{cluster}'
AS default.libp2p_gossipsub_aggregate_and_proof_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_gossipsub_aggregate_and_proof_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, peer_id_unique_key, message_id))
COMMENT 'Table for libp2p gossipsub aggregate and proof data.';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_beacon_attestation ON CLUSTER '{cluster}'
AS default.libp2p_gossipsub_beacon_attestation_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_gossipsub_beacon_attestation_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, peer_id_unique_key, message_id))
COMMENT 'Table for libp2p gossipsub beacon attestation data.';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_beacon_block ON CLUSTER '{cluster}'
AS default.libp2p_gossipsub_beacon_block_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_gossipsub_beacon_block_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, peer_id_unique_key, message_id))
COMMENT 'Table for libp2p gossipsub beacon block data.';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_blob_sidecar ON CLUSTER '{cluster}'
AS default.libp2p_gossipsub_blob_sidecar_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_gossipsub_blob_sidecar_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, peer_id_unique_key, message_id))
COMMENT 'Table for libp2p gossipsub blob sidecar data';

CREATE TABLE IF NOT EXISTS default.libp2p_gossipsub_data_column_sidecar ON CLUSTER '{cluster}'
AS default.libp2p_gossipsub_data_column_sidecar_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_gossipsub_data_column_sidecar_local', cityHash64(slot_start_date_time, meta_network_name, meta_client_name, peer_id_unique_key, message_id))
COMMENT 'Table for libp2p gossipsub data column sidecar data';

CREATE TABLE IF NOT EXISTS default.libp2p_graft ON CLUSTER '{cluster}'
AS default.libp2p_graft_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_graft_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name))
COMMENT 'Contains the details of the GRAFT events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_handle_metadata ON CLUSTER '{cluster}'
AS default.libp2p_handle_metadata_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_handle_metadata_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, latency_milliseconds))
COMMENT 'Contains the metadata handling events for libp2p peers.';

CREATE TABLE IF NOT EXISTS default.libp2p_handle_status ON CLUSTER '{cluster}'
AS default.libp2p_handle_status_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_handle_status_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, latency_milliseconds))
COMMENT 'Contains the status handling events for libp2p peers.';

CREATE TABLE IF NOT EXISTS default.libp2p_identify ON CLUSTER '{cluster}'
AS default.libp2p_identify_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_identify_local', cityHash64(event_date_time, meta_network_name, meta_client_name, remote_peer_id_unique_key, direction))
COMMENT 'Contains libp2p identify protocol exchange results including remote peer agent info, supported protocols, and connection metadata';

CREATE TABLE IF NOT EXISTS default.libp2p_join ON CLUSTER '{cluster}'
AS default.libp2p_join_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_join_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name))
COMMENT 'Contains the details of the JOIN events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_leave ON CLUSTER '{cluster}'
AS default.libp2p_leave_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_leave_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name))
COMMENT 'Contains the details of the LEAVE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_peer ON CLUSTER '{cluster}'
AS default.libp2p_peer_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_peer_local', unique_key)
COMMENT 'Lookup table mapping seahashed peer_id + network to original peer ID. Collected from deep instrumentation within forked consensus layer clients. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_prune ON CLUSTER '{cluster}'
AS default.libp2p_prune_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_prune_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name))
COMMENT 'Contains the details of the PRUNE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_publish_message ON CLUSTER '{cluster}'
AS default.libp2p_publish_message_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_publish_message_local', cityHash64(event_date_time, meta_network_name, meta_client_name, topic_fork_digest_value, topic_name, message_id))
COMMENT 'Contains the details of the PUBLISH_MESSAGE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_recv_rpc ON CLUSTER '{cluster}'
AS default.libp2p_recv_rpc_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_recv_rpc_local', unique_key)
COMMENT 'Contains RPC messages received from peers. Collected from deep instrumentation within forked consensus layer clients. Control messages are split into separate tables referencing this via rpc_meta_unique_key. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_reject_message ON CLUSTER '{cluster}'
AS default.libp2p_reject_message_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_reject_message_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, topic_fork_digest_value, topic_name, message_id, seq_number))
COMMENT 'Contains the details of the REJECT_MESSAGE events from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_remove_peer ON CLUSTER '{cluster}'
AS default.libp2p_remove_peer_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_remove_peer_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key))
COMMENT 'Contains the details of the peers removed from the libp2p client.';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_data_column_custody_probe ON CLUSTER '{cluster}'
AS default.libp2p_rpc_data_column_custody_probe_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_rpc_data_column_custody_probe_local', cityHash64(event_date_time, meta_network_name, meta_client_name, peer_id_unique_key, slot, column_index))
COMMENT 'Contains custody probe events for data column availability verification';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_graft ON CLUSTER '{cluster}'
AS default.libp2p_rpc_meta_control_graft_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_rpc_meta_control_graft_local', unique_key)
COMMENT 'Contains GRAFT control messages from gossipsub RPC. Collected from deep instrumentation within forked consensus layer clients. Peers request to join the mesh for a topic. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_idontwant ON CLUSTER '{cluster}'
AS default.libp2p_rpc_meta_control_idontwant_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_rpc_meta_control_idontwant_local', unique_key)
COMMENT 'Contains the details of the IDONTWANT control messages from the peer.';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_ihave ON CLUSTER '{cluster}'
AS default.libp2p_rpc_meta_control_ihave_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_rpc_meta_control_ihave_local', unique_key)
COMMENT 'Contains IHAVE control messages from gossipsub. Collected from deep instrumentation within forked consensus layer clients. Peers advertise message IDs they have available. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_iwant ON CLUSTER '{cluster}'
AS default.libp2p_rpc_meta_control_iwant_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_rpc_meta_control_iwant_local', unique_key)
COMMENT 'Contains IWANT control messages from gossipsub. Collected from deep instrumentation within forked consensus layer clients. Peers request specific message IDs. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_control_prune ON CLUSTER '{cluster}'
AS default.libp2p_rpc_meta_control_prune_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_rpc_meta_control_prune_local', unique_key)
COMMENT 'Contains PRUNE control messages from gossipsub RPC. Collected from deep instrumentation within forked consensus layer clients. Peers are removed from the mesh for a topic. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_message ON CLUSTER '{cluster}'
AS default.libp2p_rpc_meta_message_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_rpc_meta_message_local', unique_key)
COMMENT 'Contains RPC message metadata from gossipsub. Collected from deep instrumentation within forked consensus layer clients. Each row represents a message within an RPC with topic and message ID. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_rpc_meta_subscription ON CLUSTER '{cluster}'
AS default.libp2p_rpc_meta_subscription_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_rpc_meta_subscription_local', unique_key)
COMMENT 'Contains RPC subscription changes from gossipsub. Collected from deep instrumentation within forked consensus layer clients. Each row represents a subscribe/unsubscribe action for a topic. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_send_rpc ON CLUSTER '{cluster}'
AS default.libp2p_send_rpc_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_send_rpc_local', unique_key)
COMMENT 'Contains RPC messages sent to peers. Collected from deep instrumentation within forked consensus layer clients. Control messages are split into separate tables referencing this via rpc_meta_unique_key. Partition: monthly by `event_date_time`';

CREATE TABLE IF NOT EXISTS default.libp2p_synthetic_heartbeat ON CLUSTER '{cluster}'
AS default.libp2p_synthetic_heartbeat_local
ENGINE = Distributed('{cluster}', 'default', 'libp2p_synthetic_heartbeat_local', cityHash64(event_date_time, meta_network_name, meta_client_name, remote_peer_id_unique_key, updated_date_time))
COMMENT 'Contains heartbeat events from libp2p peers';

CREATE TABLE IF NOT EXISTS default.mempool_dumpster_transaction ON CLUSTER '{cluster}'
AS default.mempool_dumpster_transaction_local
ENGINE = Distributed('{cluster}', 'default', 'mempool_dumpster_transaction_local', cityHash64(timestamp, chain_id, hash, from, nonce, gas))
COMMENT 'Contains transactions from mempool dumpster dataset. Following the parquet schema with some additions';

CREATE TABLE IF NOT EXISTS default.mempool_transaction ON CLUSTER '{cluster}'
AS default.mempool_transaction_local
ENGINE = Distributed('{cluster}', 'default', 'mempool_transaction_local', cityHash64(event_date_time, meta_network_name, meta_client_name, hash, from, nonce, gas))
COMMENT 'Each row represents a transaction that was seen in the mempool by a sentry client. Sentries can report the same transaction multiple times if it has been long enough since the last report.';

CREATE TABLE IF NOT EXISTS default.mev_relay_bid_trace ON CLUSTER '{cluster}'
AS default.mev_relay_bid_trace_local
ENGINE = Distributed('{cluster}', 'default', 'mev_relay_bid_trace_local', cityHash64(slot, meta_network_name))
COMMENT 'Contains MEV relay block bids data.';

CREATE TABLE IF NOT EXISTS default.mev_relay_proposer_payload_delivered ON CLUSTER '{cluster}'
AS default.mev_relay_proposer_payload_delivered_local
ENGINE = Distributed('{cluster}', 'default', 'mev_relay_proposer_payload_delivered_local', cityHash64(slot, meta_network_name))
COMMENT 'Contains MEV relay proposer payload delivered data.';

CREATE TABLE IF NOT EXISTS default.mev_relay_validator_registration ON CLUSTER '{cluster}'
AS default.mev_relay_validator_registration_local
ENGINE = Distributed('{cluster}', 'default', 'mev_relay_validator_registration_local', cityHash64(slot, meta_network_name))
COMMENT 'Contains MEV relay validator registrations data.';

CREATE TABLE IF NOT EXISTS default.node_record_consensus ON CLUSTER '{cluster}'
AS default.node_record_consensus_local
ENGINE = Distributed('{cluster}', 'default', 'node_record_consensus_local', cityHash64(event_date_time, meta_network_name, enr, meta_client_name))
COMMENT 'Contains consensus node records discovered by the Xatu discovery module.';

CREATE TABLE IF NOT EXISTS default.node_record_execution ON CLUSTER '{cluster}'
AS default.node_record_execution_local
ENGINE = Distributed('{cluster}', 'default', 'node_record_execution_local', cityHash64(event_date_time, meta_network_name, node_id, meta_client_name))
COMMENT 'Contains execution node records discovered by the Xatu discovery module.';

-- observoor database

CREATE TABLE IF NOT EXISTS observoor.block_merge ON CLUSTER '{cluster}'
AS observoor.block_merge_local
ENGINE = Distributed('{cluster}', 'observoor', 'block_merge_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated block device I/O merge metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.cpu_utilization ON CLUSTER '{cluster}'
AS observoor.cpu_utilization_local
ENGINE = Distributed('{cluster}', 'observoor', 'cpu_utilization_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated CPU utilization metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.disk_bytes ON CLUSTER '{cluster}'
AS observoor.disk_bytes_local
ENGINE = Distributed('{cluster}', 'observoor', 'disk_bytes_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated disk I/O byte metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.disk_latency ON CLUSTER '{cluster}'
AS observoor.disk_latency_local
ENGINE = Distributed('{cluster}', 'observoor', 'disk_latency_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated disk I/O latency metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.disk_queue_depth ON CLUSTER '{cluster}'
AS observoor.disk_queue_depth_local
ENGINE = Distributed('{cluster}', 'observoor', 'disk_queue_depth_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated disk queue depth metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.fd_close ON CLUSTER '{cluster}'
AS observoor.fd_close_local
ENGINE = Distributed('{cluster}', 'observoor', 'fd_close_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated file descriptor close metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.fd_open ON CLUSTER '{cluster}'
AS observoor.fd_open_local
ENGINE = Distributed('{cluster}', 'observoor', 'fd_open_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated file descriptor open metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.host_specs ON CLUSTER '{cluster}'
AS observoor.host_specs_local
ENGINE = Distributed('{cluster}', 'observoor', 'host_specs_local', cityHash64(event_time, meta_network_name, host_id, meta_client_name))
COMMENT 'Periodic host hardware specification snapshots including CPU, memory, and disk details';

CREATE TABLE IF NOT EXISTS observoor.mem_compaction ON CLUSTER '{cluster}'
AS observoor.mem_compaction_local
ENGINE = Distributed('{cluster}', 'observoor', 'mem_compaction_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated memory compaction metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.mem_reclaim ON CLUSTER '{cluster}'
AS observoor.mem_reclaim_local
ENGINE = Distributed('{cluster}', 'observoor', 'mem_reclaim_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated memory reclaim metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.memory_usage ON CLUSTER '{cluster}'
AS observoor.memory_usage_local
ENGINE = Distributed('{cluster}', 'observoor', 'memory_usage_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Periodic memory usage snapshots of Ethereum client processes from /proc/[pid]/status';

CREATE TABLE IF NOT EXISTS observoor.net_io ON CLUSTER '{cluster}'
AS observoor.net_io_local
ENGINE = Distributed('{cluster}', 'observoor', 'net_io_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated network I/O metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.oom_kill ON CLUSTER '{cluster}'
AS observoor.oom_kill_local
ENGINE = Distributed('{cluster}', 'observoor', 'oom_kill_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated OOM kill events from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.page_fault_major ON CLUSTER '{cluster}'
AS observoor.page_fault_major_local
ENGINE = Distributed('{cluster}', 'observoor', 'page_fault_major_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated major page fault metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.page_fault_minor ON CLUSTER '{cluster}'
AS observoor.page_fault_minor_local
ENGINE = Distributed('{cluster}', 'observoor', 'page_fault_minor_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated minor page fault metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.process_exit ON CLUSTER '{cluster}'
AS observoor.process_exit_local
ENGINE = Distributed('{cluster}', 'observoor', 'process_exit_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated process exit events from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.process_fd_usage ON CLUSTER '{cluster}'
AS observoor.process_fd_usage_local
ENGINE = Distributed('{cluster}', 'observoor', 'process_fd_usage_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Periodic file descriptor usage snapshots of Ethereum client processes from /proc/[pid]/fd and /proc/[pid]/limits';

CREATE TABLE IF NOT EXISTS observoor.process_io_usage ON CLUSTER '{cluster}'
AS observoor.process_io_usage_local
ENGINE = Distributed('{cluster}', 'observoor', 'process_io_usage_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Periodic I/O usage snapshots of Ethereum client processes from /proc/[pid]/io';

CREATE TABLE IF NOT EXISTS observoor.process_sched_usage ON CLUSTER '{cluster}'
AS observoor.process_sched_usage_local
ENGINE = Distributed('{cluster}', 'observoor', 'process_sched_usage_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Periodic scheduler usage snapshots of Ethereum client processes from /proc/[pid]/status and /proc/[pid]/sched';

CREATE TABLE IF NOT EXISTS observoor.raw_events ON CLUSTER '{cluster}'
AS observoor.raw_events_local
ENGINE = Distributed('{cluster}', 'observoor', 'raw_events_local', rand())
COMMENT 'Raw eBPF events captured from Ethereum client processes, one row per kernel event';

CREATE TABLE IF NOT EXISTS observoor.sched_off_cpu ON CLUSTER '{cluster}'
AS observoor.sched_off_cpu_local
ENGINE = Distributed('{cluster}', 'observoor', 'sched_off_cpu_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated scheduler off-CPU metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.sched_on_cpu ON CLUSTER '{cluster}'
AS observoor.sched_on_cpu_local
ENGINE = Distributed('{cluster}', 'observoor', 'sched_on_cpu_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated scheduler on-CPU metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.sched_runqueue ON CLUSTER '{cluster}'
AS observoor.sched_runqueue_local
ENGINE = Distributed('{cluster}', 'observoor', 'sched_runqueue_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated scheduler run queue metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.swap_in ON CLUSTER '{cluster}'
AS observoor.swap_in_local
ENGINE = Distributed('{cluster}', 'observoor', 'swap_in_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated swap-in metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.swap_out ON CLUSTER '{cluster}'
AS observoor.swap_out_local
ENGINE = Distributed('{cluster}', 'observoor', 'swap_out_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated swap-out metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.sync_state ON CLUSTER '{cluster}'
AS observoor.sync_state_local
ENGINE = Distributed('{cluster}', 'observoor', 'sync_state_local', cityHash64(event_time, meta_network_name, meta_client_name))
COMMENT 'Sync state snapshots for consensus and execution layers';

CREATE TABLE IF NOT EXISTS observoor.syscall_epoll_wait ON CLUSTER '{cluster}'
AS observoor.syscall_epoll_wait_local
ENGINE = Distributed('{cluster}', 'observoor', 'syscall_epoll_wait_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated epoll_wait syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_fdatasync ON CLUSTER '{cluster}'
AS observoor.syscall_fdatasync_local
ENGINE = Distributed('{cluster}', 'observoor', 'syscall_fdatasync_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated fdatasync syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_fsync ON CLUSTER '{cluster}'
AS observoor.syscall_fsync_local
ENGINE = Distributed('{cluster}', 'observoor', 'syscall_fsync_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated fsync syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_futex ON CLUSTER '{cluster}'
AS observoor.syscall_futex_local
ENGINE = Distributed('{cluster}', 'observoor', 'syscall_futex_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated futex syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_mmap ON CLUSTER '{cluster}'
AS observoor.syscall_mmap_local
ENGINE = Distributed('{cluster}', 'observoor', 'syscall_mmap_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated mmap syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_pwrite ON CLUSTER '{cluster}'
AS observoor.syscall_pwrite_local
ENGINE = Distributed('{cluster}', 'observoor', 'syscall_pwrite_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated pwrite syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_read ON CLUSTER '{cluster}'
AS observoor.syscall_read_local
ENGINE = Distributed('{cluster}', 'observoor', 'syscall_read_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated read syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.syscall_write ON CLUSTER '{cluster}'
AS observoor.syscall_write_local
ENGINE = Distributed('{cluster}', 'observoor', 'syscall_write_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated write syscall metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.tcp_cwnd ON CLUSTER '{cluster}'
AS observoor.tcp_cwnd_local
ENGINE = Distributed('{cluster}', 'observoor', 'tcp_cwnd_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated TCP congestion window metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.tcp_retransmit ON CLUSTER '{cluster}'
AS observoor.tcp_retransmit_local
ENGINE = Distributed('{cluster}', 'observoor', 'tcp_retransmit_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated TCP retransmit metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.tcp_rtt ON CLUSTER '{cluster}'
AS observoor.tcp_rtt_local
ENGINE = Distributed('{cluster}', 'observoor', 'tcp_rtt_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated TCP round-trip time metrics from eBPF tracing of Ethereum client processes';

CREATE TABLE IF NOT EXISTS observoor.tcp_state_change ON CLUSTER '{cluster}'
AS observoor.tcp_state_change_local
ENGINE = Distributed('{cluster}', 'observoor', 'tcp_state_change_local', cityHash64(window_start, meta_network_name, meta_client_name))
COMMENT 'Aggregated TCP state change events from eBPF tracing of Ethereum client processes';

-- admin database

CREATE TABLE IF NOT EXISTS admin.cryo ON CLUSTER '{cluster}'
AS admin.cryo_local
ENGINE = Distributed('{cluster}', 'admin', 'cryo_local', cityHash64(dataset, mode, meta_network_name))
COMMENT 'Tracks cryo dataset processing state per block';

CREATE TABLE IF NOT EXISTS admin.execution_block ON CLUSTER '{cluster}'
AS admin.execution_block_local
ENGINE = Distributed('{cluster}', 'admin', 'execution_block_local', cityHash64(block_number, processor, meta_network_name))
COMMENT 'Tracks execution block processing state';

-- MATERIALIZED VIEWS

CREATE MATERIALIZED VIEW IF NOT EXISTS default.beacon_api_slot_attestation_mv_local ON CLUSTER '{cluster}' TO default.beacon_api_slot_local
(
    `slot` UInt32,
    `slot_start_date_time` DateTime,
    `epoch` UInt32,
    `epoch_start_date_time` DateTime,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String),
    `meta_client_geo_city` LowCardinality(String),
    `meta_client_geo_continent_code` LowCardinality(String),
    `meta_client_geo_longitude` Nullable(Float64),
    `meta_client_geo_latitude` Nullable(Float64),
    `meta_consensus_implementation` LowCardinality(String),
    `meta_consensus_version` LowCardinality(String),
    `attestations` AggregateFunction(sum, UInt32)
)
AS SELECT
    slot,
    slot_start_date_time,
    epoch,
    epoch_start_date_time,
    meta_client_name,
    meta_network_name,
    meta_client_geo_city,
    meta_client_geo_continent_code,
    meta_client_geo_longitude,
    meta_client_geo_latitude,
    meta_consensus_implementation,
    meta_consensus_version,
    sumState(toUInt32(1)) AS attestations
FROM default.beacon_api_eth_v1_events_attestation_local
GROUP BY
    slot,
    slot_start_date_time,
    epoch,
    epoch_start_date_time,
    meta_client_name,
    meta_network_name,
    meta_client_geo_city,
    meta_client_geo_continent_code,
    meta_client_geo_longitude,
    meta_client_geo_latitude,
    meta_consensus_implementation,
    meta_consensus_version;

CREATE MATERIALIZED VIEW IF NOT EXISTS default.beacon_api_slot_block_mv_local ON CLUSTER '{cluster}' TO default.beacon_api_slot_local
(
    `slot` UInt32,
    `slot_start_date_time` DateTime,
    `epoch` UInt32,
    `epoch_start_date_time` DateTime,
    `meta_client_name` LowCardinality(String),
    `meta_network_name` LowCardinality(String),
    `meta_client_geo_city` LowCardinality(String),
    `meta_client_geo_continent_code` LowCardinality(String),
    `meta_client_geo_longitude` Nullable(Float64),
    `meta_client_geo_latitude` Nullable(Float64),
    `meta_consensus_implementation` LowCardinality(String),
    `meta_consensus_version` LowCardinality(String),
    `blocks` AggregateFunction(sum, UInt16)
)
AS SELECT
    slot,
    slot_start_date_time,
    epoch,
    epoch_start_date_time,
    meta_client_name,
    meta_network_name,
    meta_client_geo_city,
    meta_client_geo_continent_code,
    meta_client_geo_longitude,
    meta_client_geo_latitude,
    meta_consensus_implementation,
    meta_consensus_version,
    sumState(toUInt16(1)) AS blocks
FROM default.beacon_api_eth_v1_events_block_local
GROUP BY
    slot,
    slot_start_date_time,
    epoch,
    epoch_start_date_time,
    meta_client_name,
    meta_network_name,
    meta_client_geo_city,
    meta_client_geo_continent_code,
    meta_client_geo_longitude,
    meta_client_geo_latitude,
    meta_consensus_implementation,
    meta_consensus_version;
